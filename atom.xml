<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>blaceman</title>
  <subtitle>懵懂 前进 憧憬</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blaceman.github.io/"/>
  <updated>2017-05-20T18:21:42.000Z</updated>
  <id>https://blaceman.github.io/</id>
  
  <author>
    <name>blaceman</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>机器学习入门</title>
    <link href="https://blaceman.github.io/2017/05/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/"/>
    <id>https://blaceman.github.io/2017/05/19/机器学习入门/</id>
    <published>2017-05-19T08:07:57.000Z</published>
    <updated>2017-05-20T18:21:42.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="机器学习入门"><a href="#机器学习入门" class="headerlink" title="机器学习入门"></a>机器学习入门</h3><p>[TOC]</p>
<h4 id="1简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><h5 id="11-什么是机器学习"><a href="#1-1-什么是机器学习" class="headerlink" title="1.1 什么是机器学习"></a>1.1 什么是机器学习</h5><p>似乎在知乎找到答案:</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1ffqv940asij30go0e1wg2.jpg" alt="Machine learning"></p>
<p>又或者说:</p>
<blockquote>
<p>- 1+1等于几 ？</p>
<p>- 50<br>- 傻x，多了</p>
<p>- 1+2等于几？<br>- 20<br>- 傻x，多了</p>
<p>- 3+4等于几<br>- 7<br>- 傻x，对了</p>
<p>- 6+9等于几<br>- 13<br>- 傻x，少了</p>
<p>很多很多次以后……</p>
<p>- 2+2等于几<br>- 4</p>
<p>- 4+5等于几<br>- 9</p>
</blockquote>
<p>哈哈哈!允许我笑那么一会儿.</p>
<h5 id="12机器学习的发展"><a href="#1-2机器学习的发展" class="headerlink" title="1.2机器学习的发展"></a>1.2机器学习的发展</h5>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;机器学习入门&quot;&gt;&lt;a href=&quot;#机器学习入门&quot; class=&quot;headerlink&quot; title=&quot;机器学习入门&quot;&gt;&lt;/a&gt;机器学习入门&lt;/h3&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h4 id=&quot;1简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerli
    
    </summary>
    
    
      <category term="1" scheme="https://blaceman.github.io/tags/1/"/>
    
  </entry>
  
  <entry>
    <title>Andrew Ng&#39;s Machine Learning First Day of the Second Week</title>
    <link href="https://blaceman.github.io/2017/03/13/Andrew-Ng-s-Machine-learning-first-day-of-the-second-week/"/>
    <id>https://blaceman.github.io/2017/03/13/Andrew-Ng-s-Machine-learning-first-day-of-the-second-week/</id>
    <published>2017-03-13T07:23:49.000Z</published>
    <updated>2017-05-19T01:22:02.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Andrew Ng&#39;s 机器学习Day Three</title>
    <link href="https://blaceman.github.io/2017/03/09/Andrew-Ng-s-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0day-three/"/>
    <id>https://blaceman.github.io/2017/03/09/Andrew-Ng-s-机器学习day-three/</id>
    <published>2017-03-09T09:16:54.000Z</published>
    <updated>2017-03-09T12:47:29.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="paramater-learning参数学习"><a href="#Paramater-Learning-参数学习" class="headerlink" title="Paramater Learning(参数学习)"></a>Paramater Learning(参数学习)</h3><h4 id="1gradient-descent梯度下降"><a href="#1-Gradient-Descent-梯度下降" class="headerlink" title="1.Gradient Descent(梯度下降)"></a>1.Gradient Descent(梯度下降)</h4><h5 id="假定我们有一个hypothesis函数我们有一个方法测量合适的数据现在我们需要估计hypothesis函数的参数这时梯度下降派上用场"><a href="#假定我们有一个hypothesis函数-我们有一个方法测量合适的数据-现在我们需要估计hypothesis函数的参数-这时梯度下降派上用场" class="headerlink" title="假定我们有一个hypothesis函数,我们有一个方法测量合适的数据,现在我们需要估计hypothesis函数的参数,这时梯度下降派上用场"></a>假定我们有一个hypothesis函数,我们有一个方法测量合适的数据,现在我们需要估计hypothesis函数的参数,这时<code>梯度下降</code>派上用场</h5><h5 id="假设我们要画出基于θ0和θ1的假设函数hypothesis实际上我们把代价函数绘制为参数估值函数-我们不是绘制x和y本身而是我们的假设函数的参数范围和由选择特定参数集所产生的代价"><a href="#假设我们要画出基于θ0和θ1的假设函数-hypothesis-实际上我们把代价函数绘制为参数估值函数-我们不是绘制x和y本身，而是我们的假设函数的参数范围和由选择特定参数集所产生的代价" class="headerlink" title="假设我们要画出基于θ0和θ1的假设函数(hypothesis)(实际上我们把代价函数绘制为参数估值函数) 我们不是绘制x和y本身，而是我们的假设函数的参数范围和由选择特定参数集所产生的代价"></a>假设我们要画出基于θ0和θ1的假设函数(hypothesis)(实际上我们把代价函数绘制为参数估值函数) 我们不是绘制x和y本身，而是我们的假设函数的参数范围和由选择特定参数集所产生的代价</h5><h5 id="我们把θ0放在x轴上把θ1放在y轴上成本函数放在垂直z轴上-我们的图上的点将是使用具有那些特定θ参数的我们的假设的代价函数的结果-下图描绘了这样的设置"><a href="#我们把θ0放在x轴上，把θ1放在y轴上，成本函数放在垂直z轴上。-我们的图上的点将是使用具有那些特定θ参数的我们的假设的代价函数的结果。-下图描绘了这样的设置" class="headerlink" title="我们把θ0放在x轴上，把θ1放在y轴上，成本函数放在垂直z轴上。 我们的图上的点将是使用具有那些特定θ参数的我们的假设的代价函数的结果。 下图描绘了这样的设置"></a>我们把θ0放在x轴上，把θ1放在y轴上，成本函数放在垂直z轴上。 我们的图上的点将是使用具有那些特定θ参数的我们的假设的代价函数的结果。 下图描绘了这样的设置</h5><p><img src="/2017/03/09/Andrew-Ng-s-机器学习day-three/1.png" alt="1"></p>
<h5 id="我们知道当我们的成本函数在图中的凹坑的最底部时即当它的值是最小值时我们已经成功-红色箭头显示图中的最小点"><a href="#我们知道，当我们的成本函数在图中的凹坑的最底部时，即当它的值是最小值时，我们已经成功。红色箭头显示图中的最小点。" class="headerlink" title="我们知道，当我们的成本函数在图中的凹坑的最底部时，即当它的值是最小值时，我们已经成功。红色箭头显示图中的最小点。"></a>我们知道，当我们的成本函数在图中的凹坑的最底部时，即当它的值是最小值时，我们已经成功。红色箭头显示图中的最小点。</h5><h5 id="我们这样做的方式是通过我们的代价函数的导数一个函数的切线-切线的斜率是在该点的导数它将给我们移动的方向-我们在具有最陡下降的方向上逐步降低代价函数-每个步骤的大小由参数α确定其被称为学习速率"><a href="#我们这样做的方式是通过我们的代价函数的导数（一个函数的切线）。切线的斜率是在该点的导数，它将给我们移动的方向。我们在具有最陡下降的方向上逐步降低代价函数。每个步骤的大小由参数α确定，其被称为学习速率。" class="headerlink" title="我们这样做的方式是通过我们的代价函数的导数（一个函数的切线）。切线的斜率是在该点的导数，它将给我们移动的方向。我们在具有最陡下降的方向上逐步降低代价函数。每个步骤的大小由参数α确定，其被称为学习速率。"></a>我们这样做的方式是通过我们的代价函数的导数（一个函数的切线）。切线的斜率是在该点的导数，它将给我们移动的方向。我们在具有最陡下降的方向上逐步降低代价函数。每个步骤的大小由参数α确定，其被称为学习速率。</h5><h5 id="例如上图中每个星之间的距离表示由我们的参数α确定的步长-较小的α将导致较小的阶跃较大的α导致较大的阶跃-步进的方向由jθ0θ1的偏导数确定-根据图表上的起始位置可以在不同的点结束-上图显示了两个不同的起点分别位于两个不同的地方"><a href="#例如，上图中每个“星”之间的距离表示由我们的参数α确定的步长。较小的α将导致较小的阶跃，较大的α导致较大的阶跃。步进的方向由J（θ0，θ1）的偏导数确定。根据图表上的起始位置，可以在不同的点结束。上图显示了两个不同的起点，分别位于两个不同的地方。" class="headerlink" title="例如，上图中每个“星”之间的距离表示由我们的参数α确定的步长。较小的α将导致较小的阶跃，较大的α导致较大的阶跃。步进的方向由J（θ0，θ1）的偏导数确定。根据图表上的起始位置，可以在不同的点结束。上图显示了两个不同的起点，分别位于两个不同的地方。"></a>例如，上图中每个“星”之间的距离表示由我们的参数α确定的步长。较小的α将导致较小的阶跃，较大的α导致较大的阶跃。步进的方向由J（θ0，θ1）的偏导数确定。根据图表上的起始位置，可以在不同的点结束。上图显示了两个不同的起点，分别位于两个不同的地方。</h5><h5 id="梯度下降算法是"><a href="#梯度下降算法是：" class="headerlink" title="梯度下降算法是："></a>梯度下降算法是：</h5><h5 id="重复直到收敛"><a href="#重复直到收敛：" class="headerlink" title="重复直到收敛："></a>重复直到收敛：</h5><h5 id="θj-θj-α-θj-jθ0θ1"><a href="#θj-θj-−-α-∂-∂θj-J-θ0-θ1" class="headerlink" title="θj:= θj − α ∂/∂θj J(θ0,θ1)"></a>θj:= θj − α ∂/∂θj J(θ0,θ1)</h5><h5 id="j-01表示特征索引号"><a href="#j-0-1表示特征索引号。" class="headerlink" title="j = 0,1表示特征索引号。"></a>j = 0,1表示特征索引号。</h5><h5 id="在每次迭代j时应该同时更新参数θ1θ2θn-在第j次迭代计算另一个参数之前更新特定参数将导致错误的实现"><a href="#在每次迭代j时，应该同时更新参数θ1，θ2，…，θn。-在第j次迭代计算另一个参数之前更新特定参数将导致错误的实现" class="headerlink" title="在每次迭代j时，应该同时更新参数θ1，θ2，…，θn。 在第j次迭代计算另一个参数之前更新特定参数将导致错误的实现"></a>在每次迭代j时，应该同时更新参数θ1，θ2，…，θn。 在第j次迭代计算另一个参数之前更新特定参数将导致错误的实现</h5><p><img src="/2017/03/09/Andrew-Ng-s-机器学习day-three/2.png" alt="2"></p>
<h4 id="2gradient-descent-intuition"><a href="#2-Gradient-Descent-Intuition" class="headerlink" title="2.Gradient Descent Intuition"></a>2.Gradient Descent Intuition</h4><h5 id="在这个视频中我们探索了一个场景其中我们使用一个参数θ1并绘制其代价函数来实现梯度下降-我们对单个参数的公式是"><a href="#在这个视频中，我们探索了一个场景，其中我们使用一个参数θ1，并绘制其代价函数来实现梯度下降。-我们对单个参数的公式是：" class="headerlink" title="在这个视频中，我们探索了一个场景，其中我们使用一个参数θ1，并绘制其代价函数来实现梯度下降。 我们对单个参数的公式是："></a>在这个视频中，我们探索了一个场景，其中我们使用一个参数θ1，并绘制其代价函数来实现梯度下降。 我们对单个参数的公式是：</h5><h5 id="重复直到收敛θ1θ1-α-ddθ1-jθ1"><a href="#重复直到收敛：θ1：-θ1-α-d-dθ1-J-θ1）" class="headerlink" title="重复直到收敛：θ1：=θ1 - α d/dθ1 J(θ1）"></a>重复直到收敛：θ1：=θ1 - α d/dθ1 J(θ1）</h5><h5 id="无论ddθ1-jθ1的斜率符号如何θ1最终收敛到其最小值-下图表示当斜率为负时θ1的值增加而当其为正时θ1的值减小"><a href="#无论d-dθ1-J-θ1）的斜率符号如何，θ1最终收敛到其最小值。-下图表示当斜率为负时，θ1的值增加，而当其为正时，θ1的值减小。" class="headerlink" title="无论d/dθ1 J(θ1）的斜率符号如何，θ1最终收敛到其最小值。 下图表示当斜率为负时，θ1的值增加，而当其为正时，θ1的值减小。"></a>无论d/dθ1 J(θ1）的斜率符号如何，θ1最终收敛到其最小值。 下图表示当斜率为负时，θ1的值增加，而当其为正时，θ1的值减小。</h5><p><img src="/2017/03/09/Andrew-Ng-s-机器学习day-three/3.png" alt="3"></p>
<h5 id="另一方面我们应该调整参数α以确保梯度下降算法在合理的时间内收敛-不收敛或太多的时间来获得最小值意味着我们的步长是错误的"><a href="#另一方面，我们应该调整参数α，以确保梯度下降算法在合理的时间内收敛。-不收敛或太多的时间来获得最小值意味着我们的步长是错误的。" class="headerlink" title="另一方面，我们应该调整参数α，以确保梯度下降算法在合理的时间内收敛。 不收敛或太多的时间来获得最小值意味着我们的步长是错误的。"></a>另一方面，我们应该调整参数α，以确保梯度下降算法在合理的时间内收敛。 不收敛或太多的时间来获得最小值意味着我们的步长是错误的。</h5><p><img src="/2017/03/09/Andrew-Ng-s-机器学习day-three/4.png" alt="4"></p>
<h5 id="梯度下降如何以固定步长α收敛"><a href="#梯度下降如何以固定步长α收敛？" class="headerlink" title="梯度下降如何以固定步长α收敛？"></a>梯度下降如何以固定步长α收敛？</h5><h5 id="收敛后面的直觉是当我们接近我们的凸函数的底部时ddθ1-jθ1接近0-至少导数将始终为0因此我们得到"><a href="#收敛后面的直觉是当我们接近我们的凸函数的底部时，d-dθ1-J-θ1）接近0。-至少，导数将始终为0，因此我们得到" class="headerlink" title="收敛后面的直觉是当我们接近我们的凸函数的底部时，d/dθ1 J(θ1）接近0。 至少，导数将始终为0，因此我们得到:"></a>收敛后面的直觉是当我们接近我们的凸函数的底部时，d/dθ1 J(θ1）接近0。 至少，导数将始终为0，因此我们得到:</h5><h5 id="θ1θ1α0"><a href="#θ1-θ1−α∗0" class="headerlink" title="θ1:=θ1−α∗0"></a><code>θ1:=θ1−α∗0</code></h5><p><img src="/2017/03/09/Andrew-Ng-s-机器学习day-three/5.png" alt="5"></p>
<h4 id="gradient-descent-for-linear-regression"><a href="#Gradient-Descent-For-Linear-Regression" class="headerlink" title="Gradient Descent For Linear Regression"></a>Gradient Descent For Linear Regression</h4><h5 id="note-at-615-hx-900-01x-should-be-hx-900-01x"><a href="#Note-At-6-15-“h-x-900-0-1x”-should-be-“h-x-900-0-1x”" class="headerlink" title="Note: [At 6:15 “h(x) = -900 - 0.1x” should be “h(x) = 900 - 0.1x”]"></a>Note: [At 6:15 “h(x) = -900 - 0.1x” should be “h(x) = 900 - 0.1x”]</h5><h5 id="当具体应用于线性回归的情况下可以导出梯度下降方程的新形式-我们可以替换我们的实际代价函数和我们的实际假设函数并将公式修改为"><a href="#当具体应用于线性回归的情况下，可以导出梯度下降方程的新形式。我们可以替换我们的实际代价函数和我们的实际假设函数，并将公式修改为：" class="headerlink" title="当具体应用于线性回归的情况下，可以导出梯度下降方程的新形式。我们可以替换我们的实际代价函数和我们的实际假设函数，并将公式修改为："></a>当具体应用于线性回归的情况下，可以导出梯度下降方程的新形式。我们可以替换我们的实际代价函数和我们的实际假设函数，并将公式修改为：</h5><p><img src="/2017/03/09/Andrew-Ng-s-机器学习day-three/6.png" alt="6"></p>
<h5 id="其中m是训练集的大小θ0是将与θ1同时改变的常数xiyi是给定训练集数据的值"><a href="#其中m是训练集的大小，θ0是将与θ1同时改变的常数，xi，yi是给定训练集（数据）的值" class="headerlink" title="其中m是训练集的大小，θ0是将与θ1同时改变的常数，xi，yi是给定训练集（数据）的值"></a>其中m是训练集的大小，θ0是将与θ1同时改变的常数，xi，yi是给定训练集（数据）的值</h5><h5 id="注意我们已经将θj的两种情况分离为θ0和θ1的单独方程并且对于θ1由于导数我们在末端乘以xi-以下是单个示例的θj-jθ的推导"><a href="#注意，我们已经将θj的两种情况分离为θ0和θ1的单独方程-并且对于θ1，由于导数，我们在末端乘以xi。以下是单个示例的∂-∂θj-J-θ）的推导：" class="headerlink" title="注意，我们已经将θj的两种情况分离为θ0和θ1的单独方程;并且对于θ1，由于导数，我们在末端乘以xi。以下是单个示例的∂/∂θj J(θ）的推导："></a>注意，我们已经将θj的两种情况分离为θ0和θ1的单独方程;并且对于θ1，由于导数，我们在末端乘以xi。以下是单个示例的∂/∂θj J(θ）的推导：</h5><p><img src="/2017/03/09/Andrew-Ng-s-机器学习day-three/7.png" alt="7"></p>
<h5 id="所有这一切的点是如果我们开始猜测我们的假设然后重复应用这些梯度下降方程我们的假设将变得越来越准确"><a href="#所有这一切的点是，如果我们开始猜测我们的假设，然后重复应用这些梯度下降方程，我们的假设将变得越来越准确。" class="headerlink" title="所有这一切的点是，如果我们开始猜测我们的假设，然后重复应用这些梯度下降方程，我们的假设将变得越来越准确。"></a>所有这一切的点是，如果我们开始猜测我们的假设，然后重复应用这些梯度下降方程，我们的假设将变得越来越准确。</h5><h5 id="因此这是对原始成本函数j的简单梯度下降-该方法查看每个步骤的整个训练集中的每个示例并且称为批量梯度下降-注意虽然梯度下降一般易受局部最小值的影响我们在这里提出的用于线性回归的优化问题只有一个全局的没有其他局部的最优的因此梯度下降总是收敛假设学习速率α不太大到全局最小值-实际上j是凸二次函数-这里是梯度下降的例子因为它运行以最小化二次函数"><a href="#因此，这是对原始成本函数J的简单梯度下降。该方法查看每个步骤的整个训练集中的每个示例，并且称为批量梯度下降。注意，虽然梯度下降一般易受局部最小值的影响，我们在这里提出的用于线性回归的优化问题只有一个全局的，没有其他局部的最优的-因此梯度下降总是收敛（假设学习速率α不太大）到全局最小值。实际上，J是凸二次函数。这里是梯度下降的例子，因为它运行以最小化二次函数。" class="headerlink" title="因此，这是对原始成本函数J的简单梯度下降。该方法查看每个步骤的整个训练集中的每个示例，并且称为批量梯度下降。注意，虽然梯度下降一般易受局部最小值的影响，我们在这里提出的用于线性回归的优化问题只有一个全局的，没有其他局部的最优的;因此梯度下降总是收敛（假设学习速率α不太大）到全局最小值。实际上，J是凸二次函数。这里是梯度下降的例子，因为它运行以最小化二次函数。"></a>因此，这是对原始成本函数J的简单梯度下降。该方法查看每个步骤的整个训练集中的每个示例，并且称为批量梯度下降。注意，虽然梯度下降一般易受局部最小值的影响，我们在这里提出的用于线性回归的优化问题只有一个全局的，没有其他局部的最优的;因此梯度下降总是收敛（假设学习速率α不太大）到全局最小值。实际上，J是凸二次函数。这里是梯度下降的例子，因为它运行以最小化二次函数。</h5><p><img src="/2017/03/09/Andrew-Ng-s-机器学习day-three/8.png" alt="8"></p>
<h5 id="上面显示的椭圆是二次函数的轮廓-还示出了由梯度下降采取的轨迹其在4830处被初始化-图中的x用直线连接标记了梯度下降经过的连续值因为它收敛到最小值"><a href="#上面显示的椭圆是二次函数的轮廓。还示出了由梯度下降采取的轨迹，其在（48-30）处被初始化。图中的x（用直线连接）标记了梯度下降经过的连续值，因为它收敛到最小值。" class="headerlink" title="上面显示的椭圆是二次函数的轮廓。还示出了由梯度下降采取的轨迹，其在（48,30）处被初始化。图中的x（用直线连接）标记了梯度下降经过的连续值，因为它收敛到最小值。"></a>上面显示的椭圆是二次函数的轮廓。还示出了由梯度下降采取的轨迹，其在（48,30）处被初始化。图中的x（用直线连接）标记了梯度下降经过的连续值，因为它收敛到最小值。</h5>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;paramater-learning参数学习&quot;&gt;&lt;a href=&quot;#Paramater-Learning-参数学习&quot; class=&quot;headerlink&quot; title=&quot;Paramater Learning(参数学习)&quot;&gt;&lt;/a&gt;Paramater Learnin
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Andrew Ng&#39;s 机器学习Day One</title>
    <link href="https://blaceman.github.io/2017/03/05/Andrew-Ng-s-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0day-one/"/>
    <id>https://blaceman.github.io/2017/03/05/Andrew-Ng-s-机器学习day-one/</id>
    <published>2017-03-05T09:11:56.000Z</published>
    <updated>2017-03-05T09:12:46.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="前言-什么是机器学习-ng老师举了几个例子谷歌网页搜索脸书或苹果的照片程序认出你的朋友电子邮件中过滤垃圾邮件的反垃圾邮件有一种科学能让计算机学习却不需要好高深的程序"><a href="#前言-什么是机器学习-NG老师举了几个例子-谷歌网页搜索-脸书或苹果的照片程序认出你的朋友-电子邮件中过滤垃圾邮件的反垃圾邮件…有一种科学能让计算机学习却不需要好高深的程序" class="headerlink" title="前言: 什么是机器学习? NG老师举了几个例子.谷歌网页搜索,脸书或苹果的照片程序认出你的朋友,电子邮件中过滤垃圾邮件的反垃圾邮件…有一种科学能让计算机学习却不需要好高深的程序"></a>前言: 什么是机器学习? NG老师举了几个例子.谷歌网页搜索,脸书或苹果的照片程序认出你的朋友,电子邮件中过滤垃圾邮件的反垃圾邮件…有一种科学能让计算机学习却不需要好高深的程序</h5><h5 id="机器学习定义-a-computer-program-is-said-to-learn-from-experience-e-with-respect-to-some-class-of-tasks-t-and-performance-measure-p-if-its-performance-at-tasks-in-t-as-measured-by-p-improves-with-experience-e"><a href="#机器学习定义-A-computer-program-is-said-to-learn-from-experience-E-with-respect-to-some-class-of-tasks-T-and-performance-measure-P-if-its-performance-at-tasks-in-T-as-measured-by-P-improves-with-experience-E-”" class="headerlink" title="机器学习定义: A computer program is said to learn from experience E with respect to some class of tasks T and performance measure P, if its performance at tasks in T, as measured by P, improves with experience E.”()"></a>机器学习定义: A computer program is said to learn from experience E with respect to some class of tasks T and performance measure P, if its performance at tasks in T, as measured by P, improves with experience E.”()</h5><p>Example: playing checkers.</p>
<p>E = the experience of playing many games of checkers</p>
<p>T = the task of playing checkers.</p>
<p>P = the probability that the program will win the next game.</p>
<h4 id="机器学习的分类-supervised-learning-and-unsupervised-learning监督学习-无监督学习"><a href="#机器学习的分类-Supervised-learning-and-Unsupervised-learning-监督学习-无监督学习" class="headerlink" title="机器学习的分类: Supervised learning and Unsupervised learning.(监督学习 无监督学习)"></a>机器学习的分类: Supervised learning and Unsupervised learning.(监督学习 无监督学习)</h4><h5 id="监督学习we-are-given-a-data-set-and-already-know-what-our-correct-output-should-look-like-having-the-idea-that-there-is-a-relationship-between-the-input-and-the-output我们已经有了一个数据集并且已经知道正确的输出应该是怎样的得到一个输出与输入的关系"><a href="#监督学习-we-are-given-a-data-set-and-already-know-what-our-correct-output-should-look-like-having-the-idea-that-there-is-a-relationship-between-the-input-and-the-output-我们已经有了一个数据集-并且已经知道正确的输出应该是怎样的-得到一个输出与输入的关系" class="headerlink" title="监督学习:we are given a data set and already know what our correct output should look like, having the idea that there is a relationship between the input and the output.(我们已经有了一个数据集,并且已经知道正确的输出应该是怎样的,得到一个输出与输入的关系)"></a>监督学习:we are given a data set and already know what our correct output should look like, having the idea that there is a relationship between the input and the output.(我们已经有了一个数据集,并且已经知道正确的输出应该是怎样的,得到一个输出与输入的关系)</h5><h5 id="监督学习分为regression回归问题和classification分类问题"><a href="#监督学习分为-Regression-回归问题-和Classification-分类问题" class="headerlink" title="监督学习分为:Regression(回归问题)和Classification(分类问题)"></a>监督学习分为:Regression(回归问题)和Classification(分类问题)</h5><h5 id="回归问题我们试图预测连续输出的结果这意味着我们试图将输入变量映射到一些连续函数"><a href="#回归问题-我们试图预测连续输出的结果，这意味着我们试图将输入变量映射到一些连续函数" class="headerlink" title="回归问题:我们试图预测连续输出的结果，这意味着我们试图将输入变量映射到一些连续函数."></a>回归问题:我们试图预测连续输出的结果，这意味着我们试图将输入变量映射到一些连续函数.</h5><h5 id="分类问题我们试图预测离散输出的结果-换句话说我们试图将输入变量映射到离散类别"><a href="#分类问题-我们试图预测离散输出的结果。换句话说，我们试图将输入变量映射到离散类别。" class="headerlink" title="分类问题:我们试图预测离散输出的结果。换句话说，我们试图将输入变量映射到离散类别。"></a>分类问题:我们试图预测离散输出的结果。换句话说，我们试图将输入变量映射到离散类别。</h5><p>Example 1:</p>
<p>Given data about the size of houses on the real estate market, try to predict their price. Price as a function of size is a continuous output, so this is a regression problem.<br><br> </p>
<p>We could turn this example into a classification problem by instead making our output about whether the house “sells for more or less than the asking price.” Here we are classifying the houses based on price into two discrete categories.<br><br><br>                   </p>
<p>Example 2:</p>
<p>(a) Regression - Given a picture of a person, we have to predict their age on the basis of the given picture(给定一个人的图片，我们必须根据给定的图片预测他们的年龄)<br><br> </p>
<p>(b) Classification - Given a patient with a tumor, we have to predict whether the tumor is malignant or benign(给定患有肿瘤的患者，我们必须预测肿瘤是恶性的还是良性的)</p>
<h5 id="无监督学习-unsupervised-learning-allows-us-to-approach-problems-with-little-or-no-idea-what-our-results-should-look-like-we-can-derive-structure-from-data-where-we-dont-necessarily-know-the-effect-of-the-variables无监督学习允许我们在不知道看起来的结果是什么的前提下可以从不知道变量的影响的数据中导出结构"><a href="#无监督学习-Unsupervised-learning-allows-us-to-approach-problems-with-little-or-no-idea-what-our-results-should-look-like-We-can-derive-structure-from-data-where-we-don’t-necessarily-know-the-effect-of-the-variables-无监督学习允许我们在不知道看起来的结果是什么的前提下-可以从不知道变量的影响的数据中导出结构" class="headerlink" title="无监督学习: Unsupervised learning allows us to approach problems with little or no idea what our results should look like. We can derive structure from data where we don’t necessarily know the effect of the variables.(无监督学习允许我们在不知道看起来的结果是什么的前提下,可以从不知道变量的影响的数据中导出结构)"></a>无监督学习: Unsupervised learning allows us to approach problems with little or no idea what our results should look like. We can derive structure from data where we don’t necessarily know the effect of the variables.(无监督学习允许我们在不知道看起来的结果是什么的前提下,可以从不知道变量的影响的数据中导出结构)</h5><h5 id="我们可以通过基于数据中的变量之间的关系对数据进行聚类clustering来导出此结构"><a href="#我们可以通过基于数据中的变量之间的关系对数据进行聚类-clustering-来导出此结构。" class="headerlink" title="我们可以通过基于数据中的变量之间的关系对数据进行聚类(clustering)来导出此结构。"></a>我们可以通过基于数据中的变量之间的关系对数据进行聚类(clustering)来导出此结构。</h5><h5 id="对于无监督学习没有基于预测结果的反馈"><a href="#对于无监督学习，没有基于预测结果的反馈。" class="headerlink" title="对于无监督学习，没有基于预测结果的反馈。"></a>对于无监督学习，没有基于预测结果的反馈。</h5><p>Example:<br><br></p>
<p>Clustering: Take a collection of 1,000,000 different genes, and find a way to automatically group these genes into groups that are somehow similar or related by different variables, such as lifespan, location, roles, and so on.(获取100万个不同基因的集合，并找到一种方法来自动将这些基因分组到不同变量（如寿命，位置，角色等）中相似或相关的组中) <br></p>
<p>Non-clustering: The “Cocktail Party Algorithm”, allows you to find structure in a chaotic environment. (i.e. identifying individual voices and music from a mesh of sounds at a cocktail party).(“鸡尾酒会算法”，允许你在混乱的环境中找到结构（即，在鸡尾酒会上从声音网中识别单个声音和音乐）)</p>
]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;前言-什么是机器学习-ng老师举了几个例子谷歌网页搜索脸书或苹果的照片程序认出你的朋友电子邮件中过滤垃圾邮件的反垃圾邮件有一种科学能让计算机学习却不需要好高深的程序&quot;&gt;&lt;a href=&quot;#前言-什么是机器学习-NG老师举了几个例子-谷歌网页搜索-脸书或苹果的照片程
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Andrew Ng&#39;s 机器学习 Day Two</title>
    <link href="https://blaceman.github.io/2017/03/02/Andrew-Ng-s-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-day-two/"/>
    <id>https://blaceman.github.io/2017/03/02/Andrew-Ng-s-机器学习-day-two/</id>
    <published>2017-03-02T10:10:21.000Z</published>
    <updated>2017-03-03T17:12:36.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="model-and-cost-function模型与代价函数"><a href="#Model-and-Cost-Function-模型与代价函数" class="headerlink" title="Model and Cost Function(模型与代价函数)"></a>Model and Cost Function(模型与代价函数)</h3><h4 id="1model-representation模型表示"><a href="#1-Model-Representation-模型表示" class="headerlink" title="1.Model Representation(模型表示):"></a>1.Model Representation(模型表示):</h4><p><img src="/2017/03/02/Andrew-Ng-s-机器学习-day-two/3.png" alt="3"></p>
<h5 id="为了建立将来使用的符号我们将使用-xi-来表示输入变量也称为输入特征并且yi表示我们试图预测的输出或目标变量价格-一对x-iy-i称为训练集符号中的上标i仅仅是训练集中的索引并且与求幂无关-我们还将使用x表示输入值的空间y表示输出值的空间"><a href="#为了建立将来使用的符号，我们将使用-x-i-来表示“输入”变量，也称为输入特征，并且y-i）表示我们试图预测的“输出”或目标变量（价格）。一对（x-（i）-，y-（i）-称为训练集，符号中的上标“（i）”仅仅是训练集中的索引，并且与求幂无关。我们还将使用X表示输入值的空间，Y表示输出值的空间" class="headerlink" title="为了建立将来使用的符号，我们将使用 x^(i) 来表示“输入”变量，也称为输入特征，并且y^(i）表示我们试图预测的“输出”或目标变量（价格）。一对（x ^ {（i）}，y ^ {（i）}称为训练集，符号中的上标“（i）”仅仅是训练集中的索引，并且与求幂无关。我们还将使用X表示输入值的空间，Y表示输出值的空间."></a>为了建立将来使用的符号，我们将使用 x^(i) 来表示“输入”变量，也称为输入特征，并且y^(i）表示我们试图预测的“输出”或目标变量（价格）。一对（x ^ {（i）}，y ^ {（i）}称为训练集，符号中的上标“（i）”仅仅是训练集中的索引，并且与求幂无关。我们还将使用X表示输入值的空间，Y表示输出值的空间.</h5><h5 id="为了更正式地描述监督学习问题我们的目标是给定一个训练集学习函数hxy使得hx是对于y的对应值的好预测器-由于历史原因该函数h称为hypothesis假设-从图像上看过程是这样的"><a href="#为了更正式地描述监督学习问题，我们的目标是，给定一个训练集，学习函数h：X→Y，使得h（x）是对于y的对应值的“好”预测器。由于历史原因，该函数h称为hypothesis-假设-。从图像上看，过程是这样的" class="headerlink" title="为了更正式地描述监督学习问题，我们的目标是，给定一个训练集，学习函数h：X→Y，使得h（x）是对于y的对应值的“好”预测器。由于历史原因，该函数h称为hypothesis(假设)。从图像上看，过程是这样的"></a>为了更正式地描述监督学习问题，我们的目标是，给定一个训练集，学习函数h：X→Y，使得h（x）是对于y的对应值的“好”预测器。由于历史原因，该函数h称为hypothesis(假设)。从图像上看，过程是这样的</h5><h5 id="当我们试图预测的目标变量是连续的例如在我们的住房示例中我们将学习问题称为回归问题-当y可以只取少量离散值时例如如果给定居住面积我们想预测住宅是房子还是公寓我们称之为分类问题"><a href="#当我们试图预测的目标变量是连续的，例如在我们的住房示例中，我们将学习问题称为回归问题。当y可以只取少量离散值时（例如，如果给定居住面积，我们想预测住宅是房子还是公寓，我们称之为分类问题）。" class="headerlink" title="当我们试图预测的目标变量是连续的，例如在我们的住房示例中，我们将学习问题称为回归问题。当y可以只取少量离散值时（例如，如果给定居住面积，我们想预测住宅是房子还是公寓，我们称之为分类问题）。"></a>当我们试图预测的目标变量是连续的，例如在我们的住房示例中，我们将学习问题称为回归问题。当y可以只取少量离散值时（例如，如果给定居住面积，我们想预测住宅是房子还是公寓，我们称之为分类问题）。</h5><h5 id="如下图所示其中m为数据集的个数"><a href="#如下图所示-其中m为数据集的个数" class="headerlink" title="如下图所示:(其中m为数据集的个数)"></a>如下图所示:(其中m为数据集的个数)</h5><p><img src="/2017/03/02/Andrew-Ng-s-机器学习-day-two/2.png" alt="2"></p>
<h4 id="2cost-function"><a href="#2-Cost-Function" class="headerlink" title="2.Cost Function"></a>2.Cost Function</h4><p><img src="/2017/03/02/Andrew-Ng-s-机器学习-day-two/4.png" alt="4"></p>
<h4 id="我们有一个训练集-可能就像我在这里绘制的-我们要做的就是-得出θ0-θ1这两个参数的值-来让假设函数表示的直线-尽量地与这些数据点很好的拟合-也许就像这里的这条线一样-那么我们如何得出θ0-θ1的值-来使它很好地拟合数据的呢我们的想法是-我们要选择-能使hx-也就是-输入x时我们预测的值-最接近该样本对应的y值的参数θ0-θ1-所以-在我们的训练集中我们会得到一定数量的样本-我们知道x表示卖出哪所房子-并且知道这所房子的实际价格-所以-我们要尽量选择参数值-使得-在训练集中-给出训练集中的x值-我们能合理准确地预测y的值-让我们给出标准的定义-在线性回归中-我们要解决的是一个最小化问题-所以我要写出关于θ0-θ1的最小化-而且-我希望这个式子极其小-是吧"><a href="#我们有一个训练集-可能就像我在这里绘制的-我们要做的就是-得出θ0-θ1这两个参数的值-来让假设函数表示的直线-尽量地与这些数据点很好的拟合-也许就像这里的这条线一样-那么我们如何得出θ0-θ1的值-来使它很好地拟合数据的呢？我们的想法是-我们要选择-能使h-x-也就是-输入x时我们预测的值-最接近该样本对应的y值的参数θ0-θ1-所以-在我们的训练集中我们会得到一定数量的样本-我们知道x表示卖出哪所房子-并且知道这所房子的实际价格-所以-我们要尽量选择参数值-使得-在训练集中-给出训练集中的x值-我们能合理准确地预测y的值-让我们给出标准的定义-在线性回归中-我们要解决的是一个最小化问题-所以我要写出关于θ0-θ1的最小化-而且-我希望这个式子极其小-是吧" class="headerlink" title="我们有一个训练集 可能就像我在这里绘制的 我们要做的就是 得出θ0 θ1这两个参数的值 来让假设函数表示的直线 尽量地与这些数据点很好的拟合 也许就像这里的这条线一样 那么我们如何得出θ0 θ1的值 来使它很好地拟合数据的呢？我们的想法是 我们要选择 能使h(x) 也就是 输入x时我们预测的值 最接近该样本对应的y值的参数θ0 θ1 所以 在我们的训练集中我们会得到一定数量的样本 我们知道x表示卖出哪所房子 并且知道这所房子的实际价格 所以 我们要尽量选择参数值 使得 在训练集中 给出训练集中的x值 我们能合理准确地预测y的值 让我们给出标准的定义 在线性回归中 我们要解决的是一个最小化问题 所以我要写出关于θ0 θ1的最小化 而且 我希望这个式子极其小 是吧"></a>我们有一个训练集 可能就像我在这里绘制的 我们要做的就是 得出θ0 θ1这两个参数的值 来让假设函数表示的直线 尽量地与这些数据点很好的拟合 也许就像这里的这条线一样 那么我们如何得出θ0 θ1的值 来使它很好地拟合数据的呢？我们的想法是 我们要选择 能使h(x) 也就是 输入x时我们预测的值 最接近该样本对应的y值的参数θ0 θ1 所以 在我们的训练集中我们会得到一定数量的样本 我们知道x表示卖出哪所房子 并且知道这所房子的实际价格 所以 我们要尽量选择参数值 使得 在训练集中 给出训练集中的x值 我们能合理准确地预测y的值 让我们给出标准的定义 在线性回归中 我们要解决的是一个最小化问题 所以我要写出关于θ0 θ1的最小化 而且 我希望这个式子极其小 是吧</h4><p><img src="/2017/03/02/Andrew-Ng-s-机器学习-day-two/7.png" alt="7"></p>
<h5 id="我们可以通过使用代价函数来测量我们的假设函数的准确性-这需要使用来自x的输入和实际输出y的假设的所有结果的平均差实际上是平均的更好的版本"><a href="#我们可以通过使用代价函数来测量我们的假设函数的准确性。-这需要使用来自x的输入和实际输出y的假设的所有结果的平均差（实际上是平均的更好的版本）。" class="headerlink" title="我们可以通过使用代价函数来测量我们的假设函数的准确性。 这需要使用来自x的输入和实际输出y的假设的所有结果的平均差（实际上是平均的更好的版本）。"></a>我们可以通过使用代价函数来测量我们的假设函数的准确性。 这需要使用来自x的输入和实际输出y的假设的所有结果的平均差（实际上是平均的更好的版本）。</h5><h5 id="为了将它分开它是12-其中-x是hθxi-yi的平方的平均值或者是预测值和实际值之间的差"><a href="#为了将它分开，它是1-2-×，其中-x是hθ（xi）-yi的平方的平均值，或者是预测值和实际值之间的差。" class="headerlink" title="为了将它分开，它是1/2 -×，其中-x是hθ（xi）-yi的平方的平均值，或者是预测值和实际值之间的差。"></a>为了将它分开，它是1/2 -×，其中-x是hθ（xi）-yi的平方的平均值，或者是预测值和实际值之间的差。</h5><h5 id="该函数另外称为平方误差函数或均方误差-为了方便计算梯度下降平均值被减半12因为平方函数的导数项将抵消12-下图总结了代价函数的作用"><a href="#该函数另外称为“平方误差函数”或“均方误差”。-为了方便计算梯度下降，平均值被减半（1-2），因为平方函数的导数项将抵消1-2。-下图总结了代价函数的作用：" class="headerlink" title="该函数另外称为“平方误差函数”或“均方误差”。 为了方便计算梯度下降，平均值被减半（1/2），因为平方函数的导数项将抵消1/2。 下图总结了代价函数的作用："></a>该函数另外称为“平方误差函数”或“均方误差”。 为了方便计算梯度下降，平均值被减半（1/2），因为平方函数的导数项将抵消1/2。 下图总结了代价函数的作用：</h5><p><img src="/2017/03/02/Andrew-Ng-s-机器学习-day-two/6.png" alt="6"></p>
<h4 id="3cost-function-intuition-itheta0-为0"><a href="#3-Cost-Function-Intuition-I-theta0-为0" class="headerlink" title="3.Cost Function - Intuition I(theta0 为0)"></a>3.Cost Function - Intuition I(theta0 为0)</h4><h5 id="直观的表示我们将建立xy坐标用一条尽可能通过所有数据集的直线"><a href="#直观的表示-我们将建立-x-y-坐标-用一条尽可能通过所有数据集的直线" class="headerlink" title="直观的表示,我们将建立(x,y)坐标,用一条尽可能通过所有数据集的直线"></a>直观的表示,我们将建立(x,y)坐标,用一条尽可能通过所有数据集的直线</h5><h5 id="我们的目标是获得最好的线-最佳可能的线将是这样的使得散射点与线的平均平方垂直距离将是最小的-理想情况下线应该通过我们训练数据集的所有点-在这种情况下-j-theta_0-theta_1的值将为0以下示例显示了我们的代价函数为0的理想情况"><a href="#我们的目标是获得最好的线。-最佳可能的线将是这样的，使得散射点与线的平均平方垂直距离将是最小的。-理想情况下，线应该通过我们训练数据集的所有点。-在这种情况下，-J（-theta-0，-theta-1）-的值将为0-以下示例显示了我们的代价函数为0的理想情况。" class="headerlink" title="我们的目标是获得最好的线。 最佳可能的线将是这样的，使得散射点与线的平均平方垂直距离将是最小的。 理想情况下，线应该通过我们训练数据集的所有点。 在这种情况下，$$ J（\ theta_0，\ theta_1）$$的值将为0.以下示例显示了我们的代价函数为0的理想情况。"></a>我们的目标是获得最好的线。 最佳可能的线将是这样的，使得散射点与线的平均平方垂直距离将是最小的。 理想情况下，线应该通过我们训练数据集的所有点。 在这种情况下，$$ J（\ theta_0，\ theta_1）$$的值将为0.以下示例显示了我们的代价函数为0的理想情况。</h5><p><img src="/2017/03/02/Andrew-Ng-s-机器学习-day-two/8.png" alt="8"></p>
<h5 id="当-theta_1-1-时我们得到的斜率为1它通过模型中的每个数据点-相反当-theta_1-05-时我们看到从我们的拟合到数据点的垂直距离增加"><a href="#当-theta-1-1-时，我们得到的斜率为1，它通过模型中的每个数据点。-相反，当-theta-1-0-5-时，我们看到从我们的拟合到数据点的垂直距离增加。" class="headerlink" title="当$$ \ theta_1 = 1 $$时，我们得到的斜率为1，它通过模型中的每个数据点。 相反，当$$ \ theta_1 = 0.5 $$时，我们看到从我们的拟合到数据点的垂直距离增加。"></a>当$$ \ theta_1 = 1 $$时，我们得到的斜率为1，它通过模型中的每个数据点。 相反，当$$ \ theta_1 = 0.5 $$时，我们看到从我们的拟合到数据点的垂直距离增加。</h5><p><img src="/2017/03/02/Andrew-Ng-s-机器学习-day-two/9.png" alt="9"></p>
<h5 id="这将我们的代价函数增加到-058-绘制其他几个点可得到以下图表"><a href="#这将我们的代价函数增加到-0-58。-绘制其他几个点可得到以下图表：" class="headerlink" title="这将我们的代价函数增加到 0.58。 绘制其他几个点可得到以下图表："></a>这将我们的代价函数增加到 0.58。 绘制其他几个点可得到以下图表：</h5><p><img src="/2017/03/02/Andrew-Ng-s-机器学习-day-two/10.png" alt="10"></p>
<h4 id="4-cost-function-intuition-iitheta_0-不为0"><a href="#4-Cost-Function-Intuition-II-theta-0-不为0" class="headerlink" title="4. Cost Function - Intuition II(theta_0 不为0)"></a>4. Cost Function - Intuition II(theta_0 不为0)</h4><h5 id="等高线图是包含许多轮廓线的图-两个可变函数的轮廓线在同一线的所有点处具有恒定值-这样的图的示例是下面的一个"><a href="#等高线图是包含许多轮廓线的图。-两个可变函数的轮廓线在同一线的所有点处具有恒定值。-这样的图的示例是下面的一个。" class="headerlink" title="等高线图是包含许多轮廓线的图。 两个可变函数的轮廓线在同一线的所有点处具有恒定值。 这样的图的示例是下面的一个。"></a>等高线图是包含许多轮廓线的图。 两个可变函数的轮廓线在同一线的所有点处具有恒定值。 这样的图的示例是下面的一个。</h5><p><img src="/2017/03/02/Andrew-Ng-s-机器学习-day-two/11.png" alt="11"></p>
<h5 id="任何颜色沿着圆人们将获得都是相同的代价函数值-例如在上面的绿线上找到的三个绿点对于-j-theta_0-theta_1具有相同的值因此它们沿着相同的线找到-当-theta_0-800和-theta_1-015时圆圈x显示左侧图形的成本函数的值-取另一个hx并绘制其等值线图得到以下图表"><a href="#任何颜色沿着“圆”，人们将获得都是相同的代价函数值。-例如，在上面的绿线上找到的三个绿点对于-J（-theta-0，-theta-1）-具有相同的值，因此，它们沿着相同的线找到。-当-theta-0-800和-theta-1-0-15时，圆圈x显示左侧图形的成本函数的值。-取另一个h（x）并绘制其等值线图，得到以下图表：" class="headerlink" title="任何颜色沿着“圆”，人们将获得都是相同的代价函数值。 例如，在上面的绿线上找到的三个绿点对于$$ J（\ theta_0，\ theta_1）$$具有相同的值，因此，它们沿着相同的线找到。 当$$ \ theta_0 $$ = 800和$$ \ theta_1 $$ = -0.15时，圆圈x显示左侧图形的成本函数的值。 取另一个h（x）并绘制其等值线图，得到以下图表："></a>任何颜色沿着“圆”，人们将获得都是相同的代价函数值。 例如，在上面的绿线上找到的三个绿点对于$$ J（\ theta_0，\ theta_1）$$具有相同的值，因此，它们沿着相同的线找到。 当$$ \ theta_0 $$ = 800和$$ \ theta_1 $$ = -0.15时，圆圈x显示左侧图形的成本函数的值。 取另一个h（x）并绘制其等值线图，得到以下图表：</h5><p><img src="/2017/03/02/Andrew-Ng-s-机器学习-day-two/12.png" alt="12"></p>
<h5 id="当-theta_0-360和-theta_1-0时轮廓图中的-j-theta_0-theta_1的值更接近中心从而降低代价函数误差-现在给我们的假设函数稍微正的斜率导致更好的数据拟合"><a href="#当-theta-0-360和-theta-1-0时，轮廓图中的-J（-theta-0，-theta-1）-的值更接近中心，从而降低代价函数误差。-现在给我们的假设函数稍微正的斜率导致更好的数据拟合。" class="headerlink" title="当$$ \ theta_0 $$ = 360和$$ \ theta_1 $$ = 0时，轮廓图中的$$ J（\ theta_0，\ theta_1）$$的值更接近中心，从而降低代价函数误差。 现在给我们的假设函数稍微正的斜率导致更好的数据拟合。"></a>当$$ \ theta_0 $$ = 360和$$ \ theta_1 $$ = 0时，轮廓图中的$$ J（\ theta_0，\ theta_1）$$的值更接近中心，从而降低代价函数误差。 现在给我们的假设函数稍微正的斜率导致更好的数据拟合。</h5><p><img src="/2017/03/02/Andrew-Ng-s-机器学习-day-two/13.png" alt="13"></p>
<h5 id="上面的图表尽可能最小化了代价函数因此-theta_1-和-theta_0-的结果分别趋向于大约012和250-在右边的图形上绘制这些值似乎将我们的点放在最内圈的中心"><a href="#上面的图表尽可能最小化了代价函数，因此，-theta-1-和-theta-0-的结果分别趋向于大约0-12和250。-在右边的图形上绘制这些值似乎将我们的点放在最内圈的中心。" class="headerlink" title="上面的图表尽可能最小化了代价函数，因此，$$ \ theta_1 $$和$$ \ theta_0 $$的结果分别趋向于大约0.12和250。 在右边的图形上绘制这些值似乎将我们的点放在最内圈的中心。"></a>上面的图表尽可能最小化了代价函数，因此，$$ \ theta_1 $$和$$ \ theta_0 $$的结果分别趋向于大约0.12和250。 在右边的图形上绘制这些值似乎将我们的点放在最内圈的中心。</h5>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;model-and-cost-function模型与代价函数&quot;&gt;&lt;a href=&quot;#Model-and-Cost-Function-模型与代价函数&quot; class=&quot;headerlink&quot; title=&quot;Model and Cost Function(模型与代价函数
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Runtimr之动态添加属性</title>
    <link href="https://blaceman.github.io/2017/02/09/runtimr%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7/"/>
    <id>https://blaceman.github.io/2017/02/09/runtimr之动态添加属性/</id>
    <published>2017-02-09T07:01:44.000Z</published>
    <updated>2017-02-09T07:12:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>在很多时候,当我们创建类别的时候,想为类别添加属性,但由于苹果不支持直接为类别添加属性,为此我们感到烦恼~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在很多时候,当我们创建类别的时候,想为类别添加属性,但由于苹果不支持直接为类别添加属性,为此我们感到烦恼~&lt;/p&gt;

    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS 宏定义那些事情</title>
    <link href="https://blaceman.github.io/2017/01/03/iOS-%E5%AE%8F%E5%AE%9A%E4%B9%89/"/>
    <id>https://blaceman.github.io/2017/01/03/iOS-宏定义/</id>
    <published>2017-01-03T03:49:37.000Z</published>
    <updated>2017-01-06T11:45:56.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="一直以来用宏定义只用了些基本的东西例如常量定义最多也就是定义一个函数很少关注宏定义高级的用法今天就说一下摸索一下高级用法~"><a href="#一直以来用宏定义只用了些基本的东西-例如常量定义-最多也就是定义一个函数-很少关注宏定义高级的用法-今天就说一下摸索一下高级用法" class="headerlink" title="一直以来用宏定义只用了些基本的东西,例如常量定义,最多也就是定义一个函数,很少关注宏定义高级的用法,今天就说一下摸索一下高级用法~"></a>一直以来用宏定义只用了些基本的东西,例如常量定义,最多也就是定义一个函数,很少关注宏定义高级的用法,今天就说一下摸索一下高级用法~</h5><h3 id="这篇文章主要说"><a href="#这篇文章主要说" class="headerlink" title="这篇文章主要说"></a>这篇文章主要说</h3><ul>
<li>宏定义的基本用法</li>
<li>高级用法</li>
<li>常用的宏定义</li>
</ul>
<p>C中的宏分为两类，对象宏(object-like macro)和函数宏(function-like macro)。</p>
<h3 id="宏定义的基本用法"><a href="#宏定义的基本用法" class="headerlink" title="宏定义的基本用法"></a>宏定义的基本用法</h3><h5 id="1定义一个圆周率对象宏"><a href="#1-定义一个圆周率-对象宏" class="headerlink" title="1.定义一个圆周率(对象宏)"></a>1.定义一个圆周率(对象宏)</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//This defines PI</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> M_PI    3.14159265358979323846264338327950288</span></div></pre></td></tr></table></figure>
<h5 id="2定义一个平方函数函数宏"><a href="#2-定义一个平方函数-函数宏" class="headerlink" title="2.定义一个平方函数(函数宏)"></a>2.定义一个平方函数(函数宏)</h5><figure class="highlight apache"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#define SQUARE(A) ((A) * (A))</span></div></pre></td></tr></table></figure>
<p>其实这并不是正确的写法,正确的写法应该使用GUN C 扩展来避免参数带运算符所带来的错误等</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#define SQUARE(<span class="name">A</span>) (&#123; __typeof__(<span class="name">A</span>) __a = (<span class="name">A</span>)<span class="comment">; __a * __a;&#125;)</span></div></pre></td></tr></table></figure>
<h3 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h3><h5 id="1首先看看系统minab"><a href="#1-首先看看系统MIN-A-B" class="headerlink" title="1.首先看看系统MIN(A,B)"></a>1.首先看看系统<code>MIN(A,B)</code></h5><figure class="highlight elm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#define __NSX_PASTE__(<span class="type">A</span>,<span class="type">B</span>) <span class="type">A</span>##<span class="type">B</span></div><div class="line">#<span class="keyword">if</span> !defined(<span class="type">MIN</span>)</div><div class="line">    #define __NSMIN_IMPL__(<span class="type">A</span>,<span class="type">B</span>,<span class="type">L</span>) (&#123; __typeof__(<span class="type">A</span>) __NSX_PASTE__(__a,<span class="type">L</span>) = (<span class="type">A</span>); __typeof__(<span class="type">B</span>) __NSX_PASTE__(__b,<span class="type">L</span>) = (<span class="type">B</span>); (__NSX_PASTE__(__a,<span class="type">L</span>) &lt; __NSX_PASTE__(__b,<span class="type">L</span>)) ? __NSX_PASTE__(__a,<span class="type">L</span>) : __NSX_PASTE__(__b,<span class="type">L</span>); &#125;)</div><div class="line">    #define <span class="type">MIN</span>(<span class="type">A</span>,<span class="type">B</span>) __NSMIN_IMPL__(<span class="type">A</span>,<span class="type">B</span>,__COUNTER__)</div><div class="line">#endif</div></pre></td></tr></table></figure>
<p>这<code>MIN(A,B)</code>分为三部分,第一部分是<code>#define __NSX_PASTE__(A,B) A##B</code>,##的意思是将A和B连接起来的意思,而第二部分是带三个参数<code>#define __NSMIN_IMPL__(A,B,L)</code>参数A,B自然是输入参数,而L则是<code>__NSX_PASTE__(__a,L)</code>定义的连接<code>__a</code>和<code>L</code>的参数名,再看第三部分<code>#define MIN(A,B) __NSMIN_IMPL__(A,B,__COUNTER__)</code>,<code>__COUNTER__</code>是一个预定义的宏，这个值在编译过程中将从0开始计数，每次被调用时加1。明显这是保证构造独立的变量名称,大大避免了变量名相同而导致问题的可能性。<br><br>我们把上诉自己定义的<code>SQUARE(A)</code>变成最接近系统那样的写法</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#define __SQUARE_IMPL__(<span class="name">A</span>,L) (&#123; __typeof__(<span class="name">A</span>) __NSX_PASTE__(<span class="name">__a</span>,L) = (<span class="name">A</span>)<span class="comment">; __NSX_PASTE__(__a,L) * __NSX_PASTE__(__a,L);&#125;)</span></div><div class="line">#define SQUARE(<span class="name">A</span>) __square_IMPL__(<span class="name">A</span>,__COUNTER__)</div></pre></td></tr></table></figure>
<h5 id="2使用-宏定义macros-__vaargs"><a href="#2-使用-宏定义macros-（-，-，…，-VAARGS" class="headerlink" title="2.使用 宏定义macros （#，##，…，__VAARGS)"></a>2.使用 宏定义macros （#，##，…，__VA<em>ARGS</em>)</h5><ul>
<li>使用”#“预处理操作符来实现将宏中的参数转化为字符串</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> WARN_IF(EXP) \  </span></div><div class="line"><span class="keyword">do</span> &#123; <span class="keyword">if</span> (EXP) \  </div><div class="line">        <span class="built_in">fprintf</span> (<span class="built_in">stderr</span>, <span class="string">"Warning: "</span> #EXP <span class="string">"\n"</span>); &#125; \  </div><div class="line"><span class="keyword">while</span> (<span class="number">0</span>)  </div><div class="line">WARN_IF (x == <span class="number">0</span>);  </div><div class="line">     ==&gt; <span class="keyword">do</span> &#123; <span class="keyword">if</span> (x == <span class="number">0</span>)  </div><div class="line">           <span class="built_in">fprintf</span> (<span class="built_in">stderr</span>, <span class="string">"Warning: "</span> <span class="string">"x == 0"</span> <span class="string">"\n"</span>); &#125; <span class="keyword">while</span> (<span class="number">0</span>);</div></pre></td></tr></table></figure>
<ul>
<li>使用”##”操作符可以实现宏中token的连接。 刚才也用过</li>
</ul>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#define __NSX_PASTE__(A,B) A##B</span></div></pre></td></tr></table></figure>
<ul>
<li>多参数宏（Variadic Macros)</li>
</ul>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#define eprintf(...) fprintf (<span class="name">stderr</span>, __VA_ARGS__)  </div><div class="line">eprintf (<span class="string">"%s:%d: "</span>, input_file, lineno)  </div><div class="line">     ==&gt;  fprintf (<span class="name">stderr</span>, <span class="string">"%s:%d: "</span>, input_file, lineno)</div></pre></td></tr></table></figure>
<p>使用标识符__VA<em>ARGS</em>来表示多个参数，在宏的名称中则使用(…)</p>
<ul>
<li>“##”的特殊用法：</li>
</ul>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#define eprintf(<span class="name">format</span>, ...) fprintf (<span class="name">stderr</span>, format, ##__VA_ARGS__)  </div><div class="line">eprintf (<span class="string">"success!\n"</span>)  </div><div class="line">     ==&gt; fprintf(<span class="name">stderr</span>, <span class="string">"success!\n"</span>)<span class="comment">;</span></div></pre></td></tr></table></figure>
<p>将”##”放在”,”和参数之间，那么如果参数留空的话，那么”##”前面的”,”就会删掉，从而防止编译错误。</p>
<ul>
<li>例如:log 重定义</li>
</ul>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Another wrong version of NSLog</span></div><div class="line"><span class="selector-id">#define</span> <span class="selector-tag">NSLog</span>(format, ...)   &#123;</div><div class="line">                               <span class="selector-tag">fprintf</span>(stderr, <span class="string">"&lt;%s : %d&gt; %s\n"</span>,                                           \</div><div class="line">                               [[[NSString <span class="attribute">stringWithUTF8String</span>:__FILE__] lastPathComponent] UTF8String],  \</div><div class="line">                               __LINE__, __func__);                                                        \</div><div class="line">                               (NSLog)((format), ##__VA_ARGS__);                                           \</div><div class="line">                               <span class="selector-tag">fprintf</span>(stderr, <span class="string">"-------\n"</span>);                                               \</div><div class="line">                             &#125;</div></pre></td></tr></table></figure>
<p>这里用到了三个预定义宏，和刚才的<code>__COUNTER__</code>类似，预定义宏的行为是由编译器指定的。<code>__FILE__</code>返回当前文件的绝对路径，<code>__LINE__</code>返回展开该宏时在文件中的行数，<code>__func__</code>是改宏所在scope的函数名称。我们在做Log输出时如果带上这这三个参数，便可以加快解读Log，迅速定位</p>
<h3 id="常用的宏定义"><a href="#常用的宏定义" class="headerlink" title="常用的宏定义"></a>常用的宏定义</h3><h5 id="输出rectsize和point的宏"><a href="#输出rect，size和point的宏" class="headerlink" title="输出rect，size和point的宏"></a>输出rect，size和point的宏</h5><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">#def</span>ine NSLogRect(rect) NSLog(@<span class="string">"%s x:%.4f, y:%.4f, w:%.4f, h:%.4f"</span>, <span class="selector-id">#rect</span>, rect<span class="selector-class">.origin</span><span class="selector-class">.x</span>, rect<span class="selector-class">.origin</span><span class="selector-class">.y</span>, rect<span class="selector-class">.size</span><span class="selector-class">.width</span>, rect<span class="selector-class">.size</span><span class="selector-class">.height</span>)</div><div class="line"><span class="number">#def</span>ine NSLogSize(size) NSLog(@<span class="string">"%s w:%.4f, h:%.4f"</span>, <span class="selector-id">#size</span>, size<span class="selector-class">.width</span>, size.<span class="attribute">height</span>)</div><div class="line"><span class="number">#def</span>ine NSLogPoint(point) NSLog(@<span class="string">"%s x:%.4f, y:%.4f"</span>, <span class="selector-id">#point</span>, point<span class="selector-class">.x</span>, point.y)</div></pre></td></tr></table></figure>
<h5 id="获取屏幕-宽度-高度"><a href="#获取屏幕-宽度、高度" class="headerlink" title="获取屏幕 宽度、高度"></a>获取屏幕 宽度、高度</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#define</span> <span class="selector-tag">SCREEN_WIDTH</span> (<span class="selector-attr">[UIScreen mainScreen]</span><span class="selector-class">.bounds</span><span class="selector-class">.size</span><span class="selector-class">.width</span>)</div><div class="line"><span class="selector-id">#define</span> <span class="selector-tag">SCREENH_HEIGHT</span> (<span class="selector-attr">[UIScreen mainScreen]</span><span class="selector-class">.bounds</span><span class="selector-class">.size</span><span class="selector-class">.height</span>)</div></pre></td></tr></table></figure>
<h5 id="系统版本"><a href="#系统版本" class="headerlink" title="系统版本"></a>系统版本</h5><figure class="highlight inform7"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#define IOS10_OR_LATER		( <span class="comment">[<span class="comment">[<span class="comment">[UIDevice currentDevice]</span> systemVersion]</span> floatValue]</span> &gt;= 10.0 )</div><div class="line">#define IOS9_OR_LATER		( <span class="comment">[<span class="comment">[<span class="comment">[UIDevice currentDevice]</span> systemVersion]</span> floatValue]</span> &gt;= 9.0  )</div><div class="line">#define IOS8_OR_LATER		( <span class="comment">[<span class="comment">[<span class="comment">[UIDevice currentDevice]</span> systemVersion]</span> floatValue]</span> &gt;= 8.0 )</div></pre></td></tr></table></figure>
<h5 id="尺寸"><a href="#尺寸" class="headerlink" title="尺寸"></a>尺寸</h5><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#define</span> <span class="selector-tag">IS_SCREEN_55_INCH</span>	([UIScreen <span class="attribute">instancesRespondToSelector</span>:<span class="variable">@selector</span>(currentMode)] ? CGSizeEqualToSize(CGSizeMake(<span class="number">1242</span>, <span class="number">2208</span>), [[UIScreen mainScreen] currentMode].size) : NO)</div><div class="line"><span class="selector-id">#define</span> <span class="selector-tag">IS_SCREEN_47_INCH</span>	([UIScreen <span class="attribute">instancesRespondToSelector</span>:<span class="variable">@selector</span>(currentMode)] ? CGSizeEqualToSize(CGSizeMake(<span class="number">750</span>, <span class="number">1334</span>), [[UIScreen mainScreen] currentMode].size) : NO)</div><div class="line"><span class="selector-id">#define</span> <span class="selector-tag">IS_SCREEN_4_INCH</span>	([UIScreen <span class="attribute">instancesRespondToSelector</span>:<span class="variable">@selector</span>(currentMode)] ? CGSizeEqualToSize(CGSizeMake(<span class="number">640</span>, <span class="number">1136</span>), [[UIScreen mainScreen] currentMode].size) : NO)</div><div class="line"><span class="selector-id">#define</span> <span class="selector-tag">IS_SCREEN_35_INCH</span>	([UIScreen <span class="attribute">instancesRespondToSelector</span>:<span class="variable">@selector</span>(currentMode)] ? CGSizeEqualToSize(CGSizeMake(<span class="number">640</span>, <span class="number">960</span>), [[UIScreen mainScreen] currentMode].size) : NO)</div></pre></td></tr></table></figure>
<h5 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h5><figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//带有RGBA的颜色设置</span></div><div class="line">#define COLOR(R, G, B, A) [UIColor colorWithRed:R/<span class="number">255.0</span> <span class="built_in">green</span>:G/<span class="number">255.0</span> <span class="built_in">blue</span>:B/<span class="number">255.0</span> <span class="built_in">alpha</span>:A]</div><div class="line">#define RandomColor [UIColor colorWithRed:arc4random_uniform(<span class="number">256</span>)/<span class="number">255.0</span> <span class="built_in">green</span>:arc4random_uniform(<span class="number">256</span>)/<span class="number">255.0</span> <span class="built_in">blue</span>:arc4random_uniform(<span class="number">256</span>)/<span class="number">255.0</span> <span class="built_in">alpha</span>:<span class="number">1.0</span>]</div></pre></td></tr></table></figure>
<h5 id="强弱引用"><a href="#强弱引用" class="headerlink" title="强弱引用"></a>强弱引用</h5><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#define LRWeakSelf(<span class="class"><span class="keyword">type</span>)  <span class="title">__weak</span> <span class="title">typeof</span></span>(<span class="class"><span class="keyword">type</span>) <span class="title">weak</span>##<span class="title">type</span> </span>= <span class="class"><span class="keyword">type</span>;</span></div><div class="line">#define LRStrongSelf(<span class="class"><span class="keyword">type</span>)  <span class="title">__strong</span> <span class="title">typeof</span></span>(<span class="class"><span class="keyword">type</span>) <span class="title">type</span> </span>= weak##<span class="class"><span class="keyword">type</span>;</span></div></pre></td></tr></table></figure>
<h5 id="圆角边框"><a href="#圆角边框" class="headerlink" title="圆角边框"></a>圆角边框</h5><figure class="highlight tex"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#define LRViewBorderRadius(View, Radius, Width, Color)<span class="tag">\<span class="name"></span></span></div><div class="line"><span class="tag">\<span class="name"></span></span></div><div class="line"><span class="string">[View.layer setCornerRadius:(Radius)]</span>;<span class="tag">\<span class="name"></span></span></div><div class="line"><span class="string">[View.layer setMasksToBounds:YES]</span>;<span class="tag">\<span class="name"></span></span></div><div class="line"><span class="string">[View.layer setBorderWidth:(Width)]</span>;<span class="tag">\<span class="name"></span></span></div><div class="line"><span class="string">[View.layer setBorderColor:[Color CGColor]</span>]</div></pre></td></tr></table></figure>
<h5 id="模拟器真机"><a href="#模拟器真机" class="headerlink" title="模拟器真机"></a>模拟器真机</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 判断是不是iOS系统，如果是iOS系统在真机和模拟器输出都是YES</span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> TARGET_OS_IPHONE  </span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span>  </span></div><div class="line">   </div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> (TARGET_IPHONE_SIMULATOR)    </span></div><div class="line">          <span class="comment">// 在模拟器的情况下</span></div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">         <span class="comment">// 在真机情况下</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<h5 id="沙河目录"><a href="#沙河目录" class="headerlink" title="沙河目录"></a>沙河目录</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//获取temp</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> kPathTemp NSTemporaryDirectory() </span></div><div class="line">   </div><div class="line"><span class="comment">//获取沙盒 Document</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> kPathDocument [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject] </span></div><div class="line">   </div><div class="line"><span class="comment">//获取沙盒 Cache</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> kPathCache [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) firstObject]</span></div></pre></td></tr></table></figure>
<p>主要参考链接:<a href="https://onevcat.com/2014/01/black-magic-in-macro/" target="_blank" rel="external">宏定义的黑魔法</a>, <a href="http://blog.csdn.net/songrotek/article/details/8929963" target="_blank" rel="external">iOS开发 高级：使用 宏定义macros （#，##，…，__VA<em>ARGS</em>)</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;一直以来用宏定义只用了些基本的东西例如常量定义最多也就是定义一个函数很少关注宏定义高级的用法今天就说一下摸索一下高级用法~&quot;&gt;&lt;a href=&quot;#一直以来用宏定义只用了些基本的东西-例如常量定义-最多也就是定义一个函数-很少关注宏定义高级的用法-今天就说一下摸索一
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Wifi密码破解</title>
    <link href="https://blaceman.github.io/2016/12/29/wifi%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3/"/>
    <id>https://blaceman.github.io/2016/12/29/wifi密码破解/</id>
    <published>2016-12-29T05:54:23.000Z</published>
    <updated>2017-01-05T10:52:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>那天回了老家,没有网络,真是回归自然~今天就来说说mac电脑如何如何破解wifi~让没有网络的你,可以偷别人家的wifi,想想就激动~</p>
<h5 id="首先来首歌"><a href="#首先来首歌" class="headerlink" title="首先来首歌"></a>首先来首歌</h5><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="https://music.163.com/outchain/player?type=2&id=116352&auto=1&height=66"></iframe>


<h3 id="文章说了以下几个方面"><a href="#文章说了以下几个方面" class="headerlink" title="文章说了以下几个方面"></a>文章说了以下几个方面</h3><ul>
<li>安装aircrack</li>
<li>利用aircrack 进行wifi抓包</li>
<li>配合字典开始wifi破解</li>
</ul>
<h3 id="安装aircrack"><a href="#安装aircrack" class="headerlink" title="安装aircrack"></a>安装aircrack</h3><h5 id="1首先安装homebrew"><a href="#1-首先安装homebrew" class="headerlink" title="1.首先安装homebrew"></a>1.首先安装homebrew</h5><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="regexp">/usr/</span>bin<span class="regexp">/ruby -e "$(curl -fsSL https:/</span><span class="regexp">/raw.githubusercontent.com/</span>Homebrew<span class="regexp">/install/m</span>aster<span class="regexp">/install)"</span></div></pre></td></tr></table></figure>
<h5 id="2用homebrew安装aircrack"><a href="#2-用homebrew安装aircrack" class="headerlink" title="2.用homebrew安装aircrack"></a>2.用homebrew安装aircrack</h5><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">brew </span><span class="keyword">install </span>aircrack-ng</div></pre></td></tr></table></figure>
<h3 id="利用aircrack-进行wifi抓包"><a href="#利用aircrack-进行wifi抓包" class="headerlink" title="利用aircrack 进行wifi抓包"></a>利用aircrack 进行wifi抓包</h3><h5 id="1airport-监测到的附近-wifi-信息"><a href="#1-airport-监测到的附近-wifi-信息" class="headerlink" title="1.airport 监测到的附近 wifi 信息"></a>1.airport 监测到的附近 wifi 信息</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">airport <span class="_">-s</span></div></pre></td></tr></table></figure>
<p>然后就能看到一下的信息</p>
<p><img src="/2016/12/29/wifi密码破解/1.png" alt="wifi"></p>
<p>SSID 是 wifi名称，RSSI 是信号强度，CHANNEL 是信道。</p>
<h5 id="2接着挑一个信号强的进行抓包"><a href="#2-接着挑一个信号强的进行抓包" class="headerlink" title="2.接着挑一个信号强的进行抓包"></a>2.接着挑一个信号强的进行抓包</h5><figure class="highlight elm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">sudo</span> air<span class="keyword">port</span> en1 sniff  1</div></pre></td></tr></table></figure>
<p>其中en1是电脑的网卡,大部分就是en1 或en0,等待几分钟~</p>
<h5 id="3接着前往tmp文件夹查看生成后缀为cap的包然后再桌面新建一个文件夹假设我新建的文件夹名字为wifi把抓到的后缀cap的问价放进文件夹里面重新命名为01cap"><a href="#3-接着前往-tmp文件夹查看生成后缀为-cap的包-然后再桌面新建一个文件夹-假设我新建的文件夹名字为wifi-把抓到的后缀-cap的问价放进文件夹里面-重新命名为01-cap" class="headerlink" title="3.接着前往/tmp文件夹查看生成后缀为.cap的包,然后再桌面新建一个文件夹(假设我新建的文件夹名字为wifi),把抓到的后缀.cap的问价放进文件夹里面,重新命名为01.cap."></a>3.接着前往<code>/tmp</code>文件夹查看生成后缀为.cap的包,然后再桌面新建一个文件夹(假设我新建的文件夹名字为wifi),把抓到的后缀.cap的问价放进文件夹里面,重新命名为01.cap.</h5><h3 id="配合字典开始wifi破解"><a href="#配合字典开始wifi破解" class="headerlink" title="配合字典开始wifi破解"></a>配合字典开始wifi破解</h3><h5 id="1谷歌百度找到密码字典"><a href="#1-谷歌-百度-找到密码字典" class="headerlink" title="1.谷歌(百度)找到密码字典"></a>1.谷歌(百度)找到密码字典</h5><h5 id="2把字典也放进上述所创建的wifi文件夹中重命名为01text"><a href="#2-把字典也放进上述所创建的wifi文件夹中-重命名为01-text" class="headerlink" title="2.把字典也放进上述所创建的wifi文件夹中,重命名为01.text"></a>2.把字典也放进上述所创建的wifi文件夹中,重命名为01.text</h5><h5 id="3终端cd-到这个文件夹里然后查看wifi抓包情况"><a href="#3-终端cd-到这个文件夹里-然后查看wifi抓包情况" class="headerlink" title="3.终端cd 到这个文件夹里,然后查看wifi抓包情况"></a>3.终端cd 到这个文件夹里,然后查看wifi抓包情况</h5><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd ~/Desktop/wifi</div><div class="line">aircrack-ng -w <span class="number">01.</span>txt <span class="number">01.</span>cap</div></pre></td></tr></table></figure>
<p><img src="/2016/12/29/wifi密码破解/4.png" alt="4"></p>
<p>其中,Encryption中（0 handshake）是抓包失败，（1 handshake）则是抓包成功。看到第几行抓包成功，则在「Index number of target network ?」后敲回车：第几行 例如(11) <br><br>如果cap文件内全是（0 handshake），就按 command + c 组合键退出。重新回到「sudo airport en1 sniff 1」这步进行监听抓包。抓包成功率受到 wifi 信号强弱、电脑与路由器距离远近、路由器是否正处在收发数据状态的影响。总之多试几次、监听时间适当延长些，可以大大提高成功率。<br><br>如果可以的话,会进入</p>
<p><img src="/2016/12/29/wifi密码破解/2.png" alt="2"></p>
<p>接下来等待破解结果就行了，中断破解过程可以直接按 command + c 组合键退出。破解过程所需时间长短受电脑硬件配置、字典体积大小的影响。如果01.txt字典破解失败，则可以换其它字典进行破解，直到破解成功。<br>使用一个好的字典是很重要的，一个9位的纯数字字典大概1G多，结果经过几个小时的破解，如果密码是987654321就很令人郁闷了，所以最好准备几个常用的wifi密码字典，可以大大提高成功率和节省时间。常用字典可以直接百度Google搜索下载。<br><br>如果成功了就会出现</p>
<p><img src="/2016/12/29/wifi密码破解/3.jpg" alt="3"></p>
<p>然而我却一直卡在抓包那里,一直没成功过,心塞~</p>
<p>主要参考是<a href="http://chaishiwei.com/blog/562.html" target="_blank" rel="external">这里</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;那天回了老家,没有网络,真是回归自然~今天就来说说mac电脑如何如何破解wifi~让没有网络的你,可以偷别人家的wifi,想想就激动~&lt;/p&gt;
&lt;h5 id=&quot;首先来首歌&quot;&gt;&lt;a href=&quot;#首先来首歌&quot; class=&quot;headerlink&quot; title=&quot;首先来首歌&quot;&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>说说Object-C Runtime</title>
    <link href="https://blaceman.github.io/2016/12/15/%E8%AF%B4%E8%AF%B4Object-C-Runtime/"/>
    <id>https://blaceman.github.io/2016/12/15/说说Object-C-Runtime/</id>
    <published>2016-12-15T04:49:58.000Z</published>
    <updated>2017-01-06T04:33:05.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="今天照着文档来说说runtime看到一半看不下去了怪自己英文不好先写下来慢慢理解然后在看下半部分~"><a href="#今天照着文档来说说runtime-看到一半看不下去了-怪自己英文不好-…先写下来慢慢理解-然后在看下半部分" class="headerlink" title="今天照着文档来说说runtime,看到一半看不下去了(怪自己英文不好)…先写下来慢慢理解,然后在看下半部分~"></a>今天照着文档来说说runtime,看到一半看不下去了(怪自己英文不好)…先写下来慢慢理解,然后在看下半部分~</h5><p>首先还是来首歌</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="https://music.163.com/outchain/player?type=2&id= 234252&auto=1&height=66"></iframe>

<p>还是建议大家看<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048-CH1-SW1" target="_blank" rel="external">官方文档</a></p>
<p>不想看文档的朋友,推荐一篇比较好的<a href="http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/" target="_blank" rel="external">博客</a></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Object-C 语言延迟了许多从编译链接到运行时的许多决策,尽可能让这门语言动态化.这就意味着这门语言仅需要编译器是不够的,还需要运行系统来执行编译代码.运行时系统作为Object-C语言的操作系统,使它工作.</p>
<p>文档大概说了NSObject class和Object-C程序如何runtime系统进行交互.尤其是检查动态加载新类,和消息转发给其它对象的范式.文档还提供一些有关于运行时你的程序怎么寻找一些有关对象的information</p>
<p>读这篇文章,你该明白Object-C runtime 系统怎样工作和可以如何利用它.一般情况下,就算你不了解它,也不影响你编写的应用程序.</p>
<h5 id="文档目录"><a href="#文档目录" class="headerlink" title="文档目录"></a>文档目录</h5><p>这篇文章有以下章节</p>
<ul>
<li>Runtime Versions and Platforms(运行时版本与平台)</li>
<li>Interacting with the Runtime(与运行时交互)</li>
<li>Messaging(消息)</li>
<li>Dynamic Method Resolution(动态方法解析)</li>
<li>Message Forwarding(消息转发)</li>
<li>Type Encodings(类型编码)</li>
<li>Declared Properties(声明属性)</li>
</ul>
<h5 id="也可以参考"><a href="#也可以参考" class="headerlink" title="也可以参考"></a>也可以参考</h5><p><a href="https://developer.apple.com/reference/objectivec/1657527-objective_c_runtime" target="_blank" rel="external">Objective-C Runtime Reference</a>描述运行时支持库的数据结构和函数.你的程序可以使用这些和Object-C runtime系统进行交互.例如,你可以增加一些类和方法或者获得加载类的所有类定义列表</p>
<p><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/Introduction/Introduction.html#//apple_ref/doc/uid/TP40011210" target="_blank" rel="external">Programming with Objective-C</a>描述了Object-C语言</p>
<p><a href="https://developer.apple.com/library/content/releasenotes/Cocoa/RN-ObjectiveC/index.html#//apple_ref/doc/uid/TP40004309" target="_blank" rel="external">Objective-C Release Notes</a>描述了Object-C 运行时在最近OS X版本的一些变化</p>
<h3 id="runtime-versions-and-platforms运行时版本与平台"><a href="#Runtime-Versions-and-Platforms-运行时版本与平台" class="headerlink" title="Runtime Versions and Platforms(运行时版本与平台)"></a>Runtime Versions and Platforms(运行时版本与平台)</h3><p>在不同的平台中有不同的Object-C runtime 版本.</p>
<h5 id="legacy-and-modern-versions过时与现在版本"><a href="#Legacy-and-Modern-Versions-过时与现在版本" class="headerlink" title="Legacy and Modern Versions(过时与现在版本)"></a>Legacy and Modern Versions(过时与现在版本)</h5><p>在Object-C中有两个runtime版本,分别是”modern”(现在)和”legacy”(过时).modern版本是从Object-C 2.0开始到现在.Objective-C 1运行时参考中描述了运行时的legacy版本的编程接口;现在的Object-C运行时参考中描述了运行时的modern版本的编程接口.</p>
<p>modern运行时最显著的新特征是实例变量是”non-fragile”(非脆)</p>
<ul>
<li>在legacy runtime,如果你在类中改变了实例变量的布局,你必须重新编译继承于它的类</li>
<li>在modern runtime,则不需要</li>
</ul>
<h5 id="platforms平台"><a href="#Platforms-平台" class="headerlink" title="Platforms(平台)"></a>Platforms(平台)</h5><p>iPhone 应用程序和在OS X v10.5和以后的64-bit 使用modern 运行时版本.其它则使用legacy运行时版本.</p>
<h3 id="interacting-with-the-runtime与运行时交互"><a href="#Interacting-with-the-Runtime-与运行时交互" class="headerlink" title="Interacting with the Runtime(与运行时交互)"></a>Interacting with the Runtime(与运行时交互)</h3><p>Object-C编程与运行时系统交互主要是以下三个方面:1.通过Object源代码,通过NSObject类方法和直接通过runttime函数</p>
<h5 id="objective-c-source-codeobjective-c-源代码"><a href="#Objective-C-Source-Code-Objective-c-源代码" class="headerlink" title="Objective-C Source Code(Objective-c 源代码)"></a>Objective-C Source Code(Objective-c 源代码)</h5><p>大多数情况下,runtime系统通过自动的在幕后工作.你只需要写和编译Object-C源代码即可.</p>
<p>当你编译包含Object类和方法代码时,编译器会创建实现这门语言的动态特性的数据结构和函数调用.数据结构会捕获关于类、类别定义和协议声明的信息;包括在Object-C编程语言中定义类和协议中类和协议对象,也包括方法选择器(method selector)实例变量模板,和其它从源代码提取的信息.运行时最主要的是消息发送,像消息的描述.它由源代码表达式发送.</p>
<h5 id="nsobject-methodsnsobject-方法"><a href="#NSObject-Methods-NSObject-方法" class="headerlink" title="NSObject Methods(NSObject 方法)"></a>NSObject Methods(NSObject 方法)</h5><p>在Cocoa中大部分对象是NSObject子类,所以大部分对象是继承它定义的方法(NSProxy例外),因此建立了每个实例和每个对象固有的行为.然而，在少数情况下，NSObject类只定义了一个模板，用于如何做一些事情; 它不提供所有必要的代码.</p>
<p>例如,NSObject 类定义了一个description 返回字符串描述类内容实例方法.这主要用于调试 -这个CDB print-object命令打印字符串从这个方法返回.这个方法的NSObject’s实现,不知道这个类包含什么内容,所以他返回一个对象名字和地址的字符串.Object子类可以可以实现这个方法来返回更多的细节.例如，Foundation类NSArray返回它包含的对象的描述列表.</p>
<p>一些NSObject方法只是查询运行时系统的信息,这些方法允许对象执行自省.例如一些类方法,要求识别其类;<code>isKindOfClass:</code>和<code>isMemberOfClass:</code>测试对象在继承层次结构中的位置;<code>respondsToSelector:</code>指示对象是否可以接受特定消息;<code>conformsToProtocol:</code>指示对象是否宣称去实现在特定的协议中被定义的方法和<code>methodForSelector:</code>提供一个方法实现的地址.等能够自省的方法.</p>
<h5 id="runtime-functions运行时函数"><a href="#Runtime-Functions-运行时函数" class="headerlink" title="Runtime Functions(运行时函数)"></a>Runtime Functions(运行时函数)</h5><p>运行时系统是一个动态共享库，其公共接口由位于目录/ usr / include / objc中的头文件中的一组函数和数据结构组成。 许多这些函数允许你使用纯C来重新使用编译器在编写Objective-C代码时所做的工作。 其他通过NSObject类的方法导出的功能的基础。 这些功能使得可以开发到运行时系统的其他接口，并产生增强开发环境的工具; 当在Objective-C中编程时不需要它们。 但是，编写Objective-C程序时，一些运行时函数有时会很有用。 所有这些函数都记录在<a href="https://developer.apple.com/reference/objectivec/1657527-objective_c_runtime" target="_blank" rel="external">Objective-C Runtime Reference.</a>。</p>
<h3 id="messaging消息"><a href="#Messaging-消息" class="headerlink" title="Messaging(消息)"></a>Messaging(消息)</h3><p>本章节描述的是如何将信息表达式转化为obj_msgSend函数调用,以及怎样按名称查找方法.怎样利用object_msgSend和怎样绕过动态绑定.</p>
<h5 id="the-objc_msgsend-functionobjc_msgsend函数"><a href="#The-objc-msgSend-Function-objc-msgSend函数" class="headerlink" title="The objc_msgSend Function(objc_msgSend函数)"></a>The objc_msgSend Function(objc_msgSend函数)</h5><p>在Objective-C中，消息在运行时之前不绑定到方法实现.编译器转换消息表达式</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[receiver message]</div></pre></td></tr></table></figure>
<p>转成换objc_msgSend消息函数,这个函数有接收者和被提到的方法名称-就是selector函数,作为主要的两个参数</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">objec_msgSend</span><span class="params">(receiver,selector)</span></span></div></pre></td></tr></table></figure>
<p>在消息传递中,参数也是通过也是传递给objc_msgSend</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">objc_msgSend</span>(<span class="params">receiver, selector, arg1, arg2, ...</span>)</span></div></pre></td></tr></table></figure>
<p>消息传递函数为动态绑定做任何事情</p>
<ul>
<li>首先找到selector的引用过程(方法的实现),相同的方法可以被不同的类实现,其精确查找依赖于receiver的类</li>
<li>然后它调用该过程，将其传递给接收对象（指向其数据的指针）以及为该方法指定的任何参数</li>
<li>最后，它传递过程的返回值作为它自己的返回值</li>
</ul>
<p>注意：编译器生成对消息传递函数的调用。 你不应该直接在你写的代码中调用它。</p>
<p>消息转发的关键在于编译器为每个类和对象构建结构。 每个类结构包括这两个基本元素：</p>
<ul>
<li>指向超类的指针。</li>
<li>类调度表。 此表具有将方法选择器与其标识的方法的类特定地址相关联的条目。 setOrigin ::方法的选择器与（实现的过程）setOrigin ::的地址相关联，显示方法的选择器与显示地址相关联，依此类推。</li>
</ul>
<p>创建新对象时，将分配其内存，并初始化其实例变量。 第一个对象的变量是一个指向它的类结构的指针。 这个指针，称为isa，给对象访问它的类，并通过类，到它继承的所有类。</p>
<p><img src="/2016/12/15/说说Object-C-Runtime/messaging1.gif" alt="message"></p>
<p>当消息发送給对象,这个消息转发函数会随着对象的isa指针到调度表寻找的方法选择器(selector)类结构.如果没有发现selector,objc_msgSend会随着指针到超类调度表寻找selector,直到NSObject.一旦找到selector,就进入表调用这个方法和传递它给接收对象的数据结构</p>
<p>这就是方法runtime方法实现的方式,或者用术语来说,方法动态绑定.</p>
<p>为了加快消息转发的过程,当它们被调用,运行时系统缓存了selector和方法的地址.而且为每个类分开做缓存.它包含继承的的方法和在类中定义的方法.在查找总调度表之前,首先查找缓存调度表.如果是在缓存找到selector,消息转发仅比函数调用略微耗时.</p>
<h5 id="using-hidden-argument使用隐藏参数"><a href="#Using-Hidden-Argument-使用隐藏参数" class="headerlink" title="Using Hidden Argument(使用隐藏参数)"></a>Using Hidden Argument(使用隐藏参数)</h5><p>在消息转发中,当objc_msgSend找到方法实现的过程,它会调用这个过程和传递它所有的参数,它也传递两个隐藏的参数:</p>
<ul>
<li>接收对象</li>
<li>方法选择器</li>
</ul>
<p>这些参数给有关引用这两个信息表达式的每一个方法实现详细的信息.它们称之为”hidden”(隐藏)是因为在方法定义的源代码没有声明.它们在代码被编译的时候被插入到实现中.</p>
<p>尽管这些参数没有明确的声明,源代码仍然可以引用它们(仅能引用接受对象的实例变量).方法引用接收对象称为self,和用用它自己的selector称为_cmd.在下面就例子中,_cmd引用了strange方法,self引用收到strange消息的对象</p>
<figure class="highlight monkey"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- strange</div><div class="line">&#123;</div><div class="line">    id  target = getTheReceiver();</div><div class="line">    SEL <span class="function"><span class="keyword">method</span> =</span> getTheMethod();</div><div class="line"> </div><div class="line">    <span class="keyword">if</span> ( target == <span class="built_in">self</span> || <span class="function"><span class="keyword">method</span> =</span>= _cmd )</div><div class="line">        <span class="keyword">return</span> nil;</div><div class="line">    <span class="keyword">return</span> [target performSelector:<span class="function"><span class="keyword">method</span>];</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>self是更有用的参数,事实上,接收对象的实例变量是可以获得方法的定义.</p>
<h5 id="getting-a-method-address获得方法地址"><a href="#Getting-a-Method-Address-获得方法地址" class="headerlink" title="Getting a Method Address(获得方法地址)"></a>Getting a Method Address(获得方法地址)</h5><p>规避动态绑定的唯一方法是获取方法的地址，并直接调用它，就像它是一个函数。 这在极少情况下可能是适当的，当特定方法将被连续执行多次，并且希望避免每次执行该方法时消息的开销。</p>
<p>使用NSObject类<code>methodForSelector</code>中定义的方法，可以要求指向实现方法的过程的指针，然后使用指针调用过程. <code>methodForSelector：</code>返回的指针必须小心地转换为正确的函数类型。 返回和参数类型都应包含在转换中。</p>
<p>下面的示例显示了如何调用实现setFilled：方法的过程：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> (*<span class="keyword">setter</span>)(<span class="keyword">id</span>, SEL, <span class="built_in">BOOL</span>);</div><div class="line"><span class="keyword">int</span> i;</div><div class="line"> </div><div class="line"><span class="keyword">setter</span> = (<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL, <span class="built_in">BOOL</span>))[target</div><div class="line">    methodForSelector:<span class="keyword">@selector</span>(setFilled:)];</div><div class="line"><span class="keyword">for</span> ( i = <span class="number">0</span> ; i &lt; <span class="number">1000</span> ; i++ )</div><div class="line">    <span class="keyword">setter</span>(targetList[i], <span class="keyword">@selector</span>(setFilled:), <span class="literal">YES</span>);</div></pre></td></tr></table></figure>
<p>传递给过程的前两个参数是接收对象（self）和方法选择器（_cmd）。 这些参数隐藏在方法语法中，但是当方法作为函数调用时必须显式。</p>
<p>使用methodForSelector：规避动态绑定可以节省消息传递所需的大部分时间。 然而，仅当特定消息被重复多次时，节省将是显着的，如在上面所示的for循环中。</p>
<p>注意，methodForSelector：由Cocoa运行时系统提供; 它不是Objective-C语言本身的一个特性。</p>
<h3 id="dynamic-method-resolution动态派发"><a href="#Dynamic-Method-Resolution-动态派发" class="headerlink" title="Dynamic Method Resolution(动态派发)"></a>Dynamic Method Resolution(动态派发)</h3><p>本章介绍如何动态提供方法的实现。</p>
<h5 id="dynamic-method-resolution-动态派发"><a href="#Dynamic-Method-Resolution-动态派发-1" class="headerlink" title="Dynamic Method Resolution (动态派发)"></a>Dynamic Method Resolution (动态派发)</h5><p>某些情况下，您可能需要动态提供方法的实现。 例如，Objective-C声明的属性特性,包括@dynamic指令：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">dynamic</span> propertyName;</div></pre></td></tr></table></figure>
<p>它告诉编译器与属性相关联的方法将被动态提供。</p>
<p>您可以实现方法<code>resolveInstanceMethod：</code>和<code>resolveClassMethod：</code>分别为实例和类方法动态提供给定选择器的实现。</p>
<p>Objective-C方法只是一个C函数，至少需要两个参数 - self和_cmd。 您可以使用函数class_addMethod将函数添加到类作为方法。 因此，给定以下函数：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> dynamicMethodIMP(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd) &#123;</div><div class="line">    <span class="comment">// implementation ....</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你可以使用<code>resolveInstanceMethod</code>动态地将它添加到一个类作为一个方法（称为resolveThisMethodDynamically）：像这样：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="variable">@implementation</span> MyClass</div><div class="line">+ (BOOL)<span class="attribute">resolveInstanceMethod</span>:(SEL)aSEL</div><div class="line">&#123;</div><div class="line">    <span class="selector-tag">if</span> (aSEL == <span class="variable">@selector</span>(resolveThisMethodDynamically)) &#123;</div><div class="line">          <span class="selector-tag">class_addMethod</span>([self class], aSEL, (IMP) dynamicMethodIMP, <span class="string">"v@:"</span>);</div><div class="line">          <span class="selector-tag">return</span> <span class="selector-tag">YES</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="selector-tag">return</span> <span class="selector-attr">[super resolveInstanceMethod:aSEL]</span>;</div><div class="line">&#125;</div><div class="line">@<span class="selector-tag">end</span></div></pre></td></tr></table></figure>
<p>转发方法（如消息转发描述）和动态方法解析是，在很大程度上，正交。 类有机会在转发机制开始之前动态地解析方法。如果调用了<code>responsesToSelector：</code>或<code>instancesRespondToSelector：</code>，动态方法解析器被给予为选择器提供IMP的机会。 如果实现<code>resolveInstanceMethod：</code>但希望特定的选择器实际上通过转发机制转发，则对这些选择器返回NO。</p>
<h5 id="dynamic-loading动态加载"><a href="#Dynamic-Loading-动态加载" class="headerlink" title="Dynamic Loading(动态加载)"></a>Dynamic Loading(动态加载)</h5><p>Objective-C程序可以在运行时加载和链接新的类和类别。新代码被合并到程序中，并且与开始时加载的类和类别完全相同。</p>
<p>动态加载可以用来做很多不同的事情。例如，系统首选项应用程序中的各个模块都是动态加载的。</p>
<p>在Cocoa环境中，通常使用动态加载来允许自定义应用程序。其他人可以编写程序在运行时加载的模块，就像Interface Builder加载自定义调色板和OS X系统首选项应用程序加载自定义首选项模块一样。可加载模块扩展了应用程序可以做什么。他们以你允许，但不能预期或定义自己的方式贡献它。你提供的框架，但其他人提供的代码。</p>
<p>虽然有一个运行时函数在Mach-O文件（objc_loadModules，在objc / objc-load.h中定义）中执行Objective-C模块的动态加载，Cocoa的NSBundle类为动态加载提供了一个非常方便的界面 - 定向和集成相关服务。有关NSBundle类及其使用的信息，请参阅Foundation框架参考中的NSBundle类规范。有关Mach-O文件的信息，请参见OS X ABI Mach-O文件格式参考</p>
<h3 id="messag-forwarding消息转发"><a href="#Messag-Forwarding-消息转发" class="headerlink" title="Messag Forwarding(消息转发)"></a>Messag Forwarding(消息转发)</h3><p>向不处理该消息的对象发送消息是一个错误。 然而，在报错之前，运行时系统给接收对象第二次处理消息的机会。</p>
<h5 id="forwarding转发"><a href="#Forwarding-转发" class="headerlink" title="Forwarding(转发)"></a>Forwarding(转发)</h5><p>如果您向不处理该消息的对象发送消息，则在发布错误之前，运行时将对象发送一个<code>forwardInvocation：</code>消息，并将<code>NSInvocation</code>对象作为其唯一参数，NSInvocation对象封装原始消息和传递的参数。</p>
<p>您可以实现<code>forwardInvocation</code>方法以给予消息默认响应，或以某种其他方式避免错误。顾名思义，<code>forwardInvocation：</code>通常用于将消息转发到另一个对象。</p>
<p>想要看看转发的范围和意图，想象以下场景：假设，首先，你设计一个对象，可以响应一个消息，称为<code>negotiate</code>，并且你想要另一对象的响应。你可以通过传递一个<code>negotiate</code>消息到你实现的<code>negotiate</code>方法的主体中的其他对象轻松地实现这一点。</p>
<p>再进一步，假设您希望对象对协商消息的响应正是在另一个类中实现的响应。实现这一点的一种方法是让你的类从另一个类继承该方法。但是，可能不可能这样安排。可能有很好的理由为什么你的类和实现协商的类在继承层次结构的不同分支。</p>
<p>即使你的类不能继承negotiate方法，你仍然可以通过实现一个版本的方法，只是将消息传递给另一个类的实例“借”它：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">-</span> (id)<span class="selector-tag">negotiate</span></div><div class="line">&#123;</div><div class="line">    <span class="selector-tag">if</span> ( [someOtherObject <span class="attribute">respondsTo</span>:<span class="variable">@selector</span>(negotiate)] )</div><div class="line">        <span class="selector-tag">return</span> <span class="selector-attr">[someOtherObject negotiate]</span>;</div><div class="line">    <span class="selector-tag">return</span> <span class="selector-tag">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种做事的方式可能会有点麻烦，特别是如果有一些消息，你想让你的对象传递给另一个对象。你必须实现一个方法来覆盖你想从另一个类借用的每个方法。此外，它是不可能处理的情况下，你不知道，在你写代码的时候，你可能要转发的完整的消息集。该集合可能取决于运行时的事件，并且可能随着新方法和类在将来实现而改变。</p>
<p><code>forwardInvocation：</code>message提供的第二次机会为这个问题提供了一个不太特别的解决方案，动态解决的而不是静态的。它的工作原理是这样的：当对象不能响应消息，因为它没有匹配消息中的选择器的方法，运行时系统通过发送一个<code>forwardInvocation：</code>消息通知对象。每个对象从NSObject类继承<code>forwardInvocation：</code>方法。然而，NSObject的版本的方法只是调用doesNotRecognizeSelector：。通过重写NSObject的版本并实现自己的，你可以利用<code>forwardInvocation：</code>message提供的将消息转发给其他对象的机会。</p>
<p>要转发消息，所有forwardInvocation：方法需要做的是：</p>
<ul>
<li>确定消息应该到哪里，和</li>
<li>发送它的原始参数。</li>
</ul>
<p>消息可以使用<code>invokeWithTarget：</code>方法发送：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)<span class="string">forwardInvocation:</span>(NSInvocation *)anInvocation</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> ([someOtherObject <span class="string">respondsToSelector:</span></div><div class="line">            [anInvocation selector]])</div><div class="line">        [anInvocation <span class="string">invokeWithTarget:</span>someOtherObject];</div><div class="line">    <span class="keyword">else</span></div><div class="line">        [<span class="keyword">super</span> <span class="string">forwardInvocation:</span>anInvocation];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>被转发消息的返回值被返回到原来的Sender(发送发),所有类型的返回值都可以传递给发送方，包括ids，double和双精度浮点数。</p>
<p><code>forwardInvocation：</code>方法可以充当未识别消息的分发中心，将它们分解到不同的接收方。 或者它可以是转移站，将所有消息发送到相同的目的地。 它可以将一个消息转换为另一个消息，或者简单地“吞下”一些消息，所以没有响应和没有错误。 <code>forwardInvocation：</code>方法还可以将多个消息合并为单个响应。 <code>forwardInvocation：</code>做的事情给实现者。 然而，它提供用于在转发链中链接对象的机会为程序设计打开了可能性。</p>
<p>注意：<code>forwardInvocation：</code>方法仅在它们不调用名义接收器中的现有方法时才处理消息。 例如，如果您希望对象将negotiate消息转发给另一个对象，则它不能具有自己的negotiate方法。 如果有，消息将永远不会到达<code>forwardInvocation：</code>。<br>有关转发和调用的更多信息，请参阅Foundation框架参考中的NSInvocation类规范。</p>
<h5 id="forwarding-and-multiple-inheritance转发和多继承"><a href="#Forwarding-and-Multiple-Inheritance-转发和多继承" class="headerlink" title="Forwarding and Multiple Inheritance(转发和多继承)"></a>Forwarding and Multiple Inheritance(转发和多继承)</h5><p>转发模拟继承，可用于将多重继承的一些影响借给Objective-C程序，通过转发消息来响应消息的对象似乎借用或“继承”另一个类中定义的方法实现。</p>
<p><img src="/2016/12/15/说说Object-C-Runtime/forwarding.gif" alt="forwarding"></p>
<p>在此图中，Warrior类的实例将negotiate消息转发到Diplomat类的实例。Warrior就像像Diplomat调用negotiate。Warrior似乎对negotiate的信息作出反应，并且为了所有实际目做出回应（它就像真的是一个Diplomat(外交官)，正在做的工作）。</p>
<p>转发消息的对象因此从继承层次结构的两个分支“继承”方法 - 它自己的分支和响应消息的对象的分支。在上面的例子中，Warrior类继承自Diplomat以及它自己的超类。</p>
<p>转发提供了您通常希望从多重继承的大多数功能。但是，这两者之间有一个重要的区别：多重继承将单个对象中的不同能力组合在一起。它倾向于大，多面的对象。另一方面，转发为不同的对象分配单独的职责。它将问题分解为较小的对象，但以对消息发送方透明的方式关联这些对象</p>
<h5 id="surrogate-objects代替对象"><a href="#Surrogate-Objects-代替对象" class="headerlink" title="Surrogate Objects(代替对象)"></a>Surrogate Objects(代替对象)</h5><p>转发不仅模仿多重继承，还使得开发表示或“覆盖”更实质对象的轻量级对象成为可能。</p>
<p>在Objective-C编程语言的“远程消息”中讨论的代理是这样的surrogate(代理)。代理负责将消息转发到远程接收器的管理细节，确保在连接上复制和检索参数值，等等。但它不试图做许多其他;它不重复远程对象的功能，而只是给远程对象一个本地地址，它可以在另一个应用程序中接收消息。</p>
<p>其他类型的替代对象也是可能的。假设，例如，你有一个对象操纵大量的数据 - 或许它创建一个复杂的图像或读取磁盘上的文件的内容。将此对象设置为向上可能是耗时的，所以你更喜欢做它懒惰 - 当它真的需要或当系统资源暂时空闲时。同时，您至少需要一个此对象的占位符，以便应用程序中的其他对象正常工作。</p>
<p>在这种情况下，你最初可以创建，不是完整的对象，是一个轻量级的代理。这个对象可以自己做一些事情，例如回答有关数据的问题，但大多数情况下，它只是为较大的对象保存一个地方，当时间到来时，转发消息给它。当代理的<code>forwardInvocation：</code>方法首先接收到目的地为另一个对象的消息时，它将确保该对象存在，并且如果它不存在则将创建它。对于较大对象的所有消息通过代理，因此，就程序的其余部分而言，代理和较大对象将是相同的。</p>
<h5 id="forwarding-and-inheritance转发和继承"><a href="#Forwarding-and-Inheritance-转发和继承" class="headerlink" title="Forwarding and Inheritance(转发和继承)"></a>Forwarding and Inheritance(转发和继承)</h5><p>虽然转发模仿继承，NSObject类从不混淆两者。 像<code>responsesToSelector：</code>和<code>isKindOfClass</code>这样的方法：只看继承层次结构，从不看转发链。 例如，如果一个Warrior对象被询问是否响应negotiate消息，</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">if</span> ( [aWarrior <span class="attribute">respondsToSelector</span>:<span class="variable">@selector</span>(negotiate)] )</div><div class="line">    ...</div></pre></td></tr></table></figure>
<p>答案是否定的，即使它可以无误地接收negotiate消息，并在某种意义上通过将它们转发给Diplomat来对它们作出响应。</p>
<p>在许多情况下，NO是正确的答案。 但它可能不是。 如果使用转发来设置代理对象或扩展类的功能，则转发机制应该像继承一样透明。 如果你想让对象的行为好像真的继承了他们转发消息的对象的行为，你需要重新实现<code>responsesToSelector：</code>和<code>isKindOfClass：</code>方法来包含你的转发算法：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (BOOL)respondsToSelector:(SEL)aSelector</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> ( [super respondsToSelector:aSelector] )</div><div class="line"><span class="built_in">        return</span> YES;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        /* Here, test whether <span class="keyword">the</span> aSelector message can     *</div><div class="line">         * be forwarded <span class="keyword">to</span> another object <span class="keyword">and</span> whether <span class="keyword">that</span>  *</div><div class="line">         * object can respond <span class="keyword">to</span> <span class="keyword">it</span>. Return YES <span class="keyword">if</span> <span class="keyword">it</span> can.  */</div><div class="line">    &#125;</div><div class="line"><span class="built_in">    return</span> NO;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>除了<code>responsesToSelector：</code>和<code>isKindOfClass：</code>，<code>instancesRespondToSelector：</code>方法也应该镜像转发算法。 如果使用协议，那么也应该将<code>conformsToProtocol：</code>方法添加到列表中。 类似地，如果一个对象转发它接收的任何远程消息，它应该有一个版本的<code>methodSignatureForSelector：</code>它可以返回最终响应转发消息的方法的准确描述; 例如，如果对象能够将消息转发到其代理，则可以实现<code>methodSignatureForSelector：</code>如下所示</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (NSMethodSignature*)<span class="string">methodSignatureForSelector:</span>(SEL)selector</div><div class="line">&#123;</div><div class="line">    NSMethodSignature* signature = [<span class="keyword">super</span> <span class="string">methodSignatureForSelector:</span>selector];</div><div class="line">    <span class="keyword">if</span> (!signature) &#123;</div><div class="line">       signature = [surrogate <span class="string">methodSignatureForSelector:</span>selector];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> signature;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你可能会考虑把转发算法放在私人代码中，并由<code>forwardInvocation：included</code>，调用它。</p>
<p>注意：这是一种高级技术，仅适用于没有其他解决方案的情况。 它不是作为继承的替代。 如果你必须使用这种技术，请确保你完全理解类的行为做转发和你转发的类。</p>
<p>本节中提到的方法在Foundation框架参考中的NSObject类规范中进行了描述。 有关invokeWithTarget：的信息，请参阅Foundation框架参考中的<a href="https://developer.apple.com/reference/foundation/nsinvocation" target="_blank" rel="external">NSInvocation</a>类规范。</p>
<h3 id="declared-properties声明属性"><a href="#Declared-Properties-声明属性" class="headerlink" title="Declared Properties(声明属性)"></a>Declared Properties(声明属性)</h3><p>当编译器遇到属性声明（请参阅Objective-C编程语言中的声明属性）时，它会生成与封闭类，类别或协议相关联的描述性元数据。 您可以使用支持按类名或协议的名称查找属性的@encode字符串获取属性的类型，以及将属性属性的列表复制为C字符串数组的函数来访问此元数据。 每个类和协议都有一个声明的属性列表。</p>
<h5 id="property-type-and-functions属性类型和函数"><a href="#Property-Type-and-Functions-属性类型和函数" class="headerlink" title="Property Type and Functions(属性类型和函数)"></a>Property Type and Functions(属性类型和函数)</h5><p>Property结构定义了属性描述符的不透明句柄</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">typedef struct objc_property *<span class="keyword">Property</span><span class="title"></span>;</div></pre></td></tr></table></figure>
<p>您可以使用函数<code>class_copyPropertyList</code>和<code>protocol_copyPropertyList</code>来检索与类（包括加载的类别）和协议相关联的属性的数组：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">objc_property_t</span> *class_copyPropertyList(Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</div><div class="line"><span class="keyword">objc_property_t</span> *protocol_copyPropertyList(Protocol *proto, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</div></pre></td></tr></table></figure>
<p>例如，给定以下类声明</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@interface</span> <span class="string">Lender :</span> NSObject &#123;</div><div class="line">    <span class="keyword">float</span> alone;</div><div class="line">&#125;</div><div class="line"><span class="meta">@property</span> <span class="keyword">float</span> alone;</div><div class="line"><span class="meta">@end</span></div></pre></td></tr></table></figure>
<p>您可以使用以下方式获取属性列表：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">id LenderClass = objc_getClass(<span class="string">"Lender"</span>)<span class="comment">;</span></div><div class="line">unsigned int outCount<span class="comment">;</span></div><div class="line">objc_property_t *properties = class_copyPropertyList(<span class="name">LenderClass</span>, <span class="symbol">&amp;outCount</span>)<span class="comment">;</span></div></pre></td></tr></table></figure>
<p>您可以使用property_getName函数来发现属性的名称：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">property_getName</span><span class="params">(<span class="keyword">objc_property_t</span> property)</span></span></div></pre></td></tr></table></figure>
<p>您可以使用函数class_getProperty和protocol_getProperty来获取对类和协议中给定名称的属性的引用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">objc_property_t</span> class_getProperty(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name)</div><div class="line"><span class="keyword">objc_property_t</span> protocol_getProperty(Protocol *proto, <span class="keyword">const</span> <span class="keyword">char</span> *name, BOOL isRequiredProperty, BOOL isInstanceProperty)</div></pre></td></tr></table></figure>
<p>您可以使用property_getAttributes函数来发现属性的名称和@encode类型字符串。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">property_getAttributes</span><span class="params">(<span class="keyword">objc_property_t</span> property)</span></span></div></pre></td></tr></table></figure>
<p>将这些组合在一起，您可以使用以下代码打印与类关联的所有属性的列表：</p>
<figure class="highlight qml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">id LenderClass = objc_getClass(<span class="string">"Lender"</span>);</div><div class="line">unsigned <span class="built_in">int</span> outCount, i;</div><div class="line">objc_property_t *properties = class_copyPropertyList(LenderClass, &amp;outCount);</div><div class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; outCount; i++) &#123;</div><div class="line">    objc_property_t <span class="keyword">property</span><span class="string"> </span>= properties[i];</div><div class="line">    fprintf(stdout, <span class="string">"%s %s\n"</span>, property_getName(<span class="keyword">property</span><span class="string">)</span>, property_getAttributes(<span class="keyword">property</span><span class="string">))</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="property-type-string属性类型字符串"><a href="#Property-Type-String-属性类型字符串" class="headerlink" title="Property Type String(属性类型字符串)"></a>Property Type String(属性类型字符串)</h5><p>您可以使用property_getAttributes函数来发现名称，属性的@encode类型字符串和属性的其他属性。</p>
<p>该字符串以一个T开头，后面跟着@encode类型和一个逗号，最后是一个V，后面跟着背景实例变量的名字。 在这些属性之间，属性由以下描述符指定，用逗号分隔</p>
]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;今天照着文档来说说runtime看到一半看不下去了怪自己英文不好先写下来慢慢理解然后在看下半部分~&quot;&gt;&lt;a href=&quot;#今天照着文档来说说runtime-看到一半看不下去了-怪自己英文不好-…先写下来慢慢理解-然后在看下半部分&quot; class=&quot;headerlin
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>个人博客的创建</title>
    <link href="https://blaceman.github.io/2016/12/06/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%88%9B%E5%BB%BA/"/>
    <id>https://blaceman.github.io/2016/12/06/个人博客的创建/</id>
    <published>2016-12-06T10:46:03.000Z</published>
    <updated>2016-12-27T07:03:10.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="最近失业有点无聊折腾一下博客然后把自己所折腾的事记录下来加深印象~"><a href="#最近失业-有点无聊-折腾一下博客-然后把自己所折腾的事记录下来-加深印象" class="headerlink" title="最近失业,有点无聊,折腾一下博客,然后把自己所折腾的事记录下来,加深印象~"></a>最近失业,有点无聊,折腾一下博客,然后把自己所折腾的事记录下来,加深印象~</h4><h4 id="首先来首歌"><a href="#首先来首歌" class="headerlink" title="首先来首歌"></a>首先来首歌</h4><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="https://music.163.com/outchain/player?type=2&id=32507038&auto=1&height=66"></iframe>


<h4 id="这篇文章大概说了以下这几个方面"><a href="#这篇文章大概说了以下这几个方面" class="headerlink" title="这篇文章大概说了以下这几个方面"></a>这篇文章大概说了以下这几个方面</h4><ol>
<li>为mac电脑安装<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="external">Hexo</a></li>
<li>基于github安装静态页面的Hexo博客</li>
<li>MarkDown常见的用法</li>
</ol>
<h3 id="1为mac电脑安装hexo"><a href="#1-为mac电脑安装Hexo" class="headerlink" title="1.为mac电脑安装Hexo"></a>1.为mac电脑安装<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="external">Hexo</a></h3><h4 id="首先hexo一款基于nodejs的静态博客框架可以生成静态文件并且一键部署到github-pages上并且他可以使用markdown来编写文章十分简单-所以安装hexo的前提必须是要安装nodejs和git而nodejs的最佳安装方式是使用nvmnode的管理工具"><a href="#首先Hexo一款基于Node-js的静态博客框架，可以生成静态文件并且一键部署到github-pages上，并且他可以使用markdown来编写文章，十分简单。所以安装Hexo的前提必须是要安装Node-JS和Git而Node-JS的最佳安装方式是使用nvm-Node的管理工具" class="headerlink" title="首先Hexo一款基于Node.js的静态博客框架，可以生成静态文件并且一键部署到github pages上，并且他可以使用markdown来编写文章，十分简单。所以安装Hexo的前提必须是要安装Node.JS和Git而Node.JS的最佳安装方式是使用nvm(Node的管理工具)"></a>首先<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="external">Hexo</a>一款基于Node.js的静态博客框架，可以生成静态文件并且一键部署到github pages上，并且他可以使用markdown来编写文章，十分简单。所以安装Hexo的前提必须是要安装Node.JS和Git而Node.JS的最佳安装方式是使用nvm(Node的管理工具)</h4><p>1.安装Git</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 安装 HomeBrew(一款软件包管理工具)</span></div><div class="line"> <span class="symbol">$</span> /usr/bin/ruby -e <span class="string">"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"</span></div><div class="line"> <span class="symbol">$</span> brew install git   <span class="comment">// 安装Git</span></div></pre></td></tr></table></figure>
<p>这里给出来HomeBrew的基本用法方便像我这样的小白阅读了解<a href="http://www.cnblogs.com/TankXiao/p/3247113.html#brewother" target="_blank" rel="external">http://www.cnblogs.com/TankXiao/p/3247113.html#brewother</a></p>
<p>2.安装nvm</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="number">1.</span> Homebrew 安装方式，此安装方式无需重启</div><div class="line"><span class="symbol">$</span> brew install nvm  </div><div class="line"><span class="symbol">$</span> mkdir ~/.nvm</div><div class="line"><span class="symbol">$</span> export NVM_DIR=~/.nvm</div><div class="line"><span class="symbol">$</span> . <span class="symbol">$</span>(brew --prefix nvm)/nvm.sh</div><div class="line"><span class="number">2.</span> curl安装方式</div><div class="line"><span class="symbol">$</span> curl https:<span class="comment">//raw.github.com/creationix/nvm/master/install.sh | sh</span></div></pre></td></tr></table></figure>
<p>同样这里也列出来nvm的基本用法<a href="http://weizhifeng.net/node-version-management-via-n-and-nvm.html" target="_blank" rel="external">http://weizhifeng.net/node-version-management-via-n-and-nvm.html</a></p>
<p>3.安装Node.JS</p>
<p><code>$ nvm install 4</code></p>
<p>4.最后一步安装Hexo</p>
<p> <code>$ sudo npm install hexo-cli -g</code></p>
<p> 至此,为创建博客做了基础的准备~顺便也给出Hexo的文档参考,参考<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="external">Hexo</a></p>
<h3 id="2创建个人博客"><a href="#2-创建个人博客" class="headerlink" title="2.创建个人博客"></a>2.创建个人博客</h3><p>1.Hexo安装完后,创建一个Github仓库,命名为<code>username</code>.github.io <strong>username是username/username.github.io的名字</strong>如果没有不懂Github,就谷歌一下吧,详细就不说</p>
<p>2.hexo 一个文件夹,文件夹名字是可以随便起的…ok,这个文件夹就是管理和发布我们的博客的,我们只需要这里面配置好我们需要的东西</p>
<p><code>hexo init username.github.io</code> </p>
<p>3.打开_config.yml,配置里面的参数的参数 简单说一下这里面的配置,还有许多设置请看<a href="http://www.jianshu.com/p/2b9f202c13fd" target="_blank" rel="external">这里</a></p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">title</span>: blaceman  <span class="comment">//博客名字</span></div><div class="line"><span class="attribute">subtitle</span>: 懵懂 前进 憧憬 <span class="comment">//副标题</span></div><div class="line"><span class="attribute">description</span>: 黄昏,一天最美丽的谢幕~ <span class="comment">//描述</span></div><div class="line"><span class="attribute">author</span>: blaceman <span class="comment">//名字</span></div><div class="line"><span class="attribute">language</span>: zh-Hans <span class="comment">//语言</span></div><div class="line"><span class="attribute">url</span>: <span class="attribute">https</span>:<span class="comment">//blaceman.github.io //url</span></div><div class="line"><span class="attribute">root</span>: /</div><div class="line"><span class="attribute">theme</span>: new-vno <span class="comment">//主题</span></div><div class="line"><span class="attribute">deploy</span>:</div><div class="line">  <span class="attribute">type</span>: git <span class="comment">//git 发布</span></div><div class="line">  <span class="attribute">repo</span>: <span class="attribute">https</span>:<span class="comment">//github.com/blaceman/blaceman.github.io.git  //Git源</span></div></pre></td></tr></table></figure>
<p>4.配置好之后,如果觉得主题丑的话,就换一下主题吧,默认是landscape hexo的众多主题<a href="https://hexo.io/themes/" target="_blank" rel="external">在这</a>,而我的主题是<a href="https://github.com/monniya/hexo-theme-new-vno" target="_blank" rel="external">这</a></p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ <span class="keyword">cd</span> username.github.io</div><div class="line">$ git clone http<span class="variable">s:</span>//github.<span class="keyword">com</span>/iissnan/hexo-theme-<span class="keyword">next</span> themes/<span class="keyword">next</span> //<span class="keyword">next</span>主题</div></pre></td></tr></table></figure>
<p>clone好之后 修改博客的_config.yml中的主题<code>theme: new-vno</code>然后在修改主题里面的_config.yml,next主题的教程<a href="http://theme-next.iissnan.com/getting-started.html#theme-settings" target="_blank" rel="external">在这</a></p>
<p>5.测试</p>
<p><code>$ hexo s</code></p>
<p> 测试服务启动，你可以在浏览器中输入<a href="https://localhost:4000" target="_blank" rel="external">https://localhost:4000</a> 访问了。觉得没问题后就可以发布了</p>
<p>6.安装hexo-deployer-git自动部署发布工具</p>
<p><code>$ npm install hexo-deployer-git --save</code></p>
<p>7.发布</p>
<p><code>$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code></p>
<p>到这一步在浏览器输入<a href="https://username.github.io" target="_blank" rel="external">https://username.github.io</a> 就可以看到你创建的博客了…</p>
<p>8.编写文章</p>
<p><code>hexo new &quot;文章名字&quot;</code></p>
<p>就在~/source/_post创建了你的.md之后你就可以用MarkDown大肆发挥了,写完后记得再次发布<br><code>$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code> </p>
<p>好了,创建博客的步骤差不多就结束了,你还可以为博客添加<strong>百度统计 谷歌统计 多说 disqueue 等第三方的东西</strong>至于怎么弄,百度一下就好~</p>
<h3 id="3markdown常见的用法"><a href="#3-MarkDown常见的用法" class="headerlink" title="3.MarkDown常见的用法"></a>3.MarkDown常见的用法</h3><p>1.常见<a href="http://www.csdn.net/article/2014-05-05/2819623" target="_blank" rel="external">MarkDowm编辑器</a>挑一个自己喜欢的就好</p>
<p>2.基本用法,我就不在写一次了,入门<a href="http://www.jianshu.com/p/q81RER" target="_blank" rel="external">在这</a>详细<a href="http://wowubuntu.com/markdown/" target="_blank" rel="external">在这</a></p>
<h3 id="完"><a href="#完…" class="headerlink" title="完…"></a>完…</h3>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;最近失业有点无聊折腾一下博客然后把自己所折腾的事记录下来加深印象~&quot;&gt;&lt;a href=&quot;#最近失业-有点无聊-折腾一下博客-然后把自己所折腾的事记录下来-加深印象&quot; class=&quot;headerlink&quot; title=&quot;最近失业,有点无聊,折腾一下博客,然后把自己所
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://blaceman.github.io/2016/11/29/12345/"/>
    <id>https://blaceman.github.io/2016/11/29/12345/</id>
    <published>2016-11-29T09:29:34.000Z</published>
    <updated>2016-12-27T06:48:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="quick-start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
  </entry>
  
</feed>
